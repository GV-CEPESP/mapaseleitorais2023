# Atividades Extras

## Marta Suplicy em 2000

Nosso primeiro passo é sempre carregar os pacotes que são relevantes para o nosso trabalho. A única novidade em relação aos exercícios anteriores é o pacote *RColorBrewer*. Já que queremos plotar mapas bonitos, ele nos auxília apresentando uma série de paletas de cores adicionais.

```{r pacotes, message = FALSE}
library(dplyr)
library(tidyr)
library(sf)
library(ggplot2)
library(ggspatial)
library(RColorBrewer)
```

Os procedimentos iniciais são muito parecidos com o que realizamos para as tarefas anteriores. Começamos baixando a base de dados que possui os resultados por local de votação na cidade de São Paulo no ano 2000 (nomeada *lv2000*). Além dela, também importaremos o mapa de distritos de São Paulo (*mapa*).

```{r importa-bases, message = FALSE}
# Importa os dados de resultado por local de votação em SP
lv2000 <- readRDS("base/base2000_sp.rds")

# Importa o mapa de distritos de São Paulo
mapa <- readRDS("base/mapa_distritos_sp.rds")
```

Agora identificaremos o total de votos por local de votação. Note que a base *lv2000* do CEM/USP já contém os dados de votação dos candidatos a prefeito. Nela, as colunas com os dados de votação seguem o seguinte padrão: PF00_111. Neste código, PF indica votação para prefeito; o primeiro dígito depois de "_" indica o turno; os dois números seguintes indicam o número do prefeito. A coluna com a votação da Marta Suplicy no primeiro turno, portanto, é PF00_113. Para mais informações, consulte a <a href="https://centrodametropole.fflch.usp.br/pt-br/file/18772/download?token=t4vNFXTg" target="blank">documentação em PDF</a> preparada pelos pesquisadores do CEM/USP.

```{r votos-por-LV, message = FALSE}
# Obtenção do total de votos validos para prefeito por local de votação
votos_pref <- lv2000 |>
  # Remove as colunas de geometria espacial
  st_drop_geometry() |>  
  # Seleciona as colunas 'ID' e um intervalo de colunas de 'PF00_111' a 'PF00_156'
  select(ID, PF00_111:PF00_156) |>  
  # Transforma as colunas de votos em linhas
  pivot_longer(cols = c(PF00_111:PF00_156),
               names_to = "coluna",
               values_to = "voto") |>  
  # Substitui valores NA em 'voto' por 0
  mutate(voto = replace_na(voto, 0)) |>  
  # Cria uma nova coluna 'voto_total' que é a soma dos votos por 'ID'
  group_by(ID) |>  
  summarise(voto_total = sum(voto)) |> 
  ungroup()
```

Nosso próximo passo, mais uma vez, é usar o comando *left_join* para integrar a base de dados de locais de votação (*lv2000*) com a de votos para prefeita (*votos_pref*) e selecionar apenas os votos da candidata Marta Suplicy. Chamaremos esta nova base de *lv2000_2*.

```{r tibble-marta, message = FALSE}
# Cria um novo tibble 'lv2000_2' a partir do 'lv2000'
lv2000_2 <- lv2000 |> 
  # Combina 'lv2000' com 'votos_pref' usando um leftjoin pelo 'ID'
  left_join(votos_pref, by = "ID") |>  
  # Seleciona as colunas 'ID', 'PF00_113' e 'voto_total'
  select(ID, PF00_113, voto_total)  
```

Agora integraremos a base de LV (ponto) com seus respecitvos distritos (poligonos). Para tal, utilizamos o comando de spacial join (*st_join*). Retire o "#" do comando abaixo e verifique o resultado.

```{r spatial-join-marta, message = FALSE}
#mapa_unificado <- st_join(lv2000_2, mapa) 
```

Oops. DEU ERRO! Você deve ter visto uma mensagem em vermelho como a seguir:

> Error in st_geos_binop("intersects", x, y, sparse = sparse, prepared = prepared,  : 
>  st_crs(x) == st_crs(y) is not TRUE

O que aconteceu? Investigue a razão! O código abaixo dá uma pista.

```{r crs-marta, message = FALSE}
# Transforma o crs para 4674
lv2000_2 <- st_transform(lv2000_2, crs = 4674) 
```

O que mudamos aqui? O sistema de referencia de coordenadas! Lembra que no último exercício vimos que existe um formato usualmente adotado nos mapas brasileiros? Ele é o SIRGAS 2000 e é indicado pelo número 4674. Agora que utilizamos o comando *st_transform* e indicamos o código correto, os dois objetos espaciais estao sob o mesmo CRS. 

Agora que está tudo certo, podemos usar o *st_join* para que os pontos sejam associados espacialmente com os polígonos.

```{r integra-bases, message = FALSE}
mapa_unificado <- st_join(mapa, lv2000_2) 
```

Por que *mapa_unificado* agora tem 1.135 linhas e não 1.134? Dica: investigue o distrito (em mapa) de Marsilac no extremo sul da cidade.

Nosso próximo passo será agrupar as votações da candidata por distrito e, como fizemos anteriormente, calcular a proporção de votos para cada uma destas localidades.

```{r porcetagem-votos-marta, message = FALSE}
# Usa o tibble 'mapa_unificado'
mapa_final <- mapa_unificado |>  
  # Calcula a soma total dos votos para 'Marta' e no total em cada distrito
  group_by(name_district) |>  
  summarise(marta = sum(PF00_113),  
            voto_total = sum(voto_total)) |>  
  ungroup() |> 
  # Calcula a porcentagem de votos para 'Marta' e arredonda para 1 casa decimal
  mutate(porc = round(marta/voto_total*100, 1))  
```

Agora precisamos decidir como vamos agrupar os dados para preparar a legenda do nosso gráfico. Ela indica como será feita a escala de cores para o nosso gráfico. Uma dica é retornar a discussão sobre Cortes de Jenks que realizamos no exercício anterior. Para este novo mapa, utilizaremos as seguintes categorias: "25-31%", "31-37%", "37-43%", e "43-49%".

```{r ajuda-visualiza-marta, message = FALSE}
# Cria uma variavel categorica para melhorar a visualizacao
mapa_final <- mutate(
  mapa_final,
  voto_cat = case_when(
    is.na(porc) ~ "Sem LV",
    TRUE ~ cut(porc,
               seq(25, 49, 6),
               labels = c("25-31%", "31-37%",
                          "37-43%", "43-49%"))))
```

Por fim, utilizaremos todos estes dados para produzir o gráfico final com a distribuição de votos (proporcional por distrito) da Marta Suplicy na eleição para prefeita no ano 2000.

```{r visualiza-marta, message = FALSE}
# Monta uma string de cores.
cores <- brewer.pal(4, "OrRd")
cores <- c(cores, "#999999")

# Inicia o ggplot
mapa_final |>
  ggplot() + 
  # Usa uma camada de sf
  geom_sf(aes_string(fill = "voto_cat"), color = "black", size = 0.1) +
  # Retira o datum
  theme_void() +
  # Coloca o fill na paleta de verdes
  scale_fill_manual(values = cores) +
  # Adicionar titulo, subtitulo e legenda
  labs(
    title = "Votação de Marta Suplicy (2000, 1º turno)",
    subtitle = "Distritos do município de São Paulo",
    caption = "Fonte: Elaborado a partir de\ndados do CEM e IBGE.") +
  # Adiciona escala
  ggspatial::annotation_scale(
    location = "br", width_hint = 0.4, line_width = 0.5, 
    height = unit(0.1,"cm")) +
  # Coloca titulo na legenda
  guides(fill = guide_legend(title = "Votos válidos")) +
  # Ajusta elementos do tema do ggplot
  theme(
    # Posicao e direcao da legenda
    legend.position = "bottom",
    legend.direction = "horizontal",
    # Centralizacao de alguns elementos textuais
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    plot.caption = element_text(hjust = 0.5)) +
  # Adiciona rosa-dos-ventos
  ggspatial::annotation_north_arrow(
    location = "br", which_north = "true",
    style = north_arrow_fancy_orienteering(),
    # Ajusta a altura da rosa-dos-ventos (pode exigir tentativa e erro)
    pad_x = unit(17.5, "cm"), pad_y = unit(8.5, "cm")) 
```


## Eduardo Paes em 2020