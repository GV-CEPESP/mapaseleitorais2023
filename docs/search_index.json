[["index.html", "Mapas Eleitorais com R Parte 1 Sobre o Workshop 1.1 Informações básicas 1.2 Pré-Requisitos 1.3 Autores", " Mapas Eleitorais com R Lucas Gelape, João V. Guedes-Neto e Marco Antonio Faganello Parte 1 Sobre o Workshop Em 2018, PT e PSL protagonizaram a disputa pela presidência. Como mostrou uma reportagem do site Pindograma, no Capão Redondo, a disputa para deputado reproduziu essa tendência. Porém, em Pinheiros, os mais votados saíram desse padrão: foram PSOL e Novo. Mapas eleitorais permitem investigar esse fenômeno. O objetivo desse workshop é ensinar os participantes a trabalhar com dados espaciais no R a partir de informações eleitorais. Nele, vamos apresentar algumas características e cuidados especiais com esse tipo de dados, como associar os resultados eleitorais ao espaço (inclusive intramunicipais), e a produzir mapas. 1.1 Informações básicas Dia: 19 de novembro de 2023 Horário: 11h15 Esse workshop é parte da programação do Coda.Br 2023. Todas as bases de dados necessárias para as atividades estão disponíveis neste link. 1.2 Pré-Requisitos R, RStudio, pacotes (tidyverse e sf). 1.3 Autores Lucas Gelape é pesquisador de pós-doutorado no CEPESP FGV, doutor em Ciência Política pela Universidade de São Paulo. Atualmente, pesquisa temas relacionados a política local e geografia eleitoral. No jornalismo, trabalhou no G1 e no Volt Data Lab/Núcleo. João V. Guedes-Neto é pesquisador de pós-doutorado no CEPESP FGV, doutor em Ciência Política pela Universidade de Pittsburgh. É especialista em psicologia política, investigando o comportamento dos eleitores, políticos e burocratas. Antes de retornar ao Brasil, foi professor na Kean University (Nova Jersey, EUA). Marco Antonio Faganello é pesquisador, cientista de dados e pós-doutorando no CEPESP FGV, doutor em Ciência Política pela Universidade Estadual de Campinas (UNICAMP). Atualmente, pesquisa temas relacionados à eleições, partidos, direita e geografia eleitoral. "],["meu-primeiro-mapa.html", "Parte 2 Meu Primeiro Mapa 2.1 A Eleição Presidencial de 2014 2.2 A Eleição Presidencial de 2022", " Parte 2 Meu Primeiro Mapa 2.1 A Eleição Presidencial de 2014 Em 2014, a então presidente Dilma Rousseff (PT) enfrentou o tucano Aécio Neves no segundo turno da eleição presidencial. Para visualizar o resultado desta disputa, elaboraremos um “mapa fácil” que colore os estados brasileiros de acordo com seu candidato mais votado naquela eleição. Para tanto, utilizaremos apenas quatro pacotes. O primeiro deles, dplyr, nos ajuda a preparar a tabela com os dados eleitorais e realizar manipulações a fim de prepará-lo para nossas análises. Com função semelhante, o sf no auxilia a manipular dados espaciais – essencial para a maior parte das análise que utilizam mapas. O ggplot2, pacote frequentemente utilizado para visualização de dados, nos ajudará a “plotar” as informações nos mapas. Por fim, o pacote geobr foi desenvolvido para obter facilmente “shapefiles” (arquivos com dados espaciais) brasileiros, os quais utilizaremos para produzir nossos mapas. ## Carregando os pacotes relevantes library(dplyr) ## Gramática para manipulação de dados library(sf) ## Gramática para dados espaciais library(ggplot2) ## Elaboração de gráficos library(geobr) ## Mapas brasileiros Nosso próximo passo é gerar uma tabela (tibble) com os dados que queremos plotar no mapa. Ou seja, uma coluna para os estados brasileiros e outra indicando o candidato vencedor. É importante notar que o nome da variável “estados” (a primeira linha da coluna) precisa estar alinhada com a nomenclatura utilizada no pacote geobr. Por esse motivo, utilizaremos o termo abbrev_state (referindo-se a abreviação dos nomes dos estados). No bloco abaixo, mostramos uma forma simples de gerar esta tabela. No entanto, também é possível produzi-la no MS Excel (ou seu software de preferência) e importá-la para o R. ganhadores_2014 &lt;- tibble( abbrev_state = c(&quot;RS&quot;, &quot;SC&quot;, &quot;PR&quot;, &quot;SP&quot;, &quot;MG&quot;, &quot;RJ&quot;, &quot;ES&quot;, &quot;MS&quot;, &quot;MT&quot;, &quot;GO&quot;, &quot;DF&quot;, &quot;TO&quot;, &quot;RO&quot;, &quot;AC&quot;, &quot;AM&quot;, &quot;PA&quot;, &quot;AP&quot;, &quot;RR&quot;, &quot;MA&quot;, &quot;PI&quot;, &quot;CE&quot;, &quot;RN&quot;, &quot;PB&quot;, &quot;PE&quot;, &quot;AL&quot;, &quot;SE&quot;, &quot;BA&quot;), ganhador = c(&quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;,&quot;Aécio&quot;, &quot;Dilma&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Aécio&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;)) A tabela (tibble) construída será como esta que apresentamos abaixo. data.frame(ganhadores_2014) ## abbrev_state ganhador ## 1 RS Aécio ## 2 SC Aécio ## 3 PR Aécio ## 4 SP Aécio ## 5 MG Dilma ## 6 RJ Dilma ## 7 ES Aécio ## 8 MS Aécio ## 9 MT Aécio ## 10 GO Aécio ## 11 DF Aécio ## 12 TO Dilma ## 13 RO Aécio ## 14 AC Aécio ## 15 AM Dilma ## 16 PA Dilma ## 17 AP Dilma ## 18 RR Aécio ## 19 MA Dilma ## 20 PI Dilma ## 21 CE Dilma ## 22 RN Dilma ## 23 PB Dilma ## 24 PE Dilma ## 25 AL Dilma ## 26 SE Dilma ## 27 BA Dilma Nosso próximo passo é baixar os dados espaciais via pacote geobr. Basicamente, queremos baixar uma tabela que contenha os estados brasileiros e informações geográficas (e geométricas!) nos informando como eles devem ser “desenhados”. mapa_brasil &lt;- read_state(code_state=&quot;all&quot;, year=2018, showProgress = FALSE) Agora temos dois objetos complementares. O ganhadores_2014 inclui qual candidato ganhou o segundo turno da eleição presidencial de 2014 em cada estado brasileiro. O mapa_brasil contém informação cartográfica sobre cada um dos estados brasileiros. Como os estados são identificados a partir da coluna abbrev_state em ambos os bancos de dados, agora podemos utilizar o comando left_join para integrá-los. ganhadores_2014 &lt;- left_join(mapa_brasil, ganhadores_2014, by = &quot;abbrev_state&quot;) Isto gera uma tabela na qual estão presentes os estados, seu devidos ganhadores e os dados espaciais. A partir destas informações, podemos usar o comando ggplot para elaborar o mapa brasileiro colorido com base nos ganhadores. Note que utilizamos a função mais básica possível para gerar este mapa. Ao longo deste workshop, aprenderemos como mudar sua aparência. ganhadores_2014 %&gt;% ggplot() + ## Gera o gráfico geom_sf(aes(fill = ganhador)) ## Identifica a coluna &quot;ganhador&quot; como fonte para colorir os estados 2.2 A Eleição Presidencial de 2022 Os mapas nos ajudam a contar uma história. Agora que geramos o mapa eleitoral da eleição presidencial de 2014, faremos o mesmo procedimento para compará-lo com o que ocorreu em 2022 quando Jair Bolsonaro (PL) foi derrotado pelo petista Lula da Silva. Mais uma vez, nosso trabalho começa a partir da criação de um tibble com os vencedores do segundo turno em cada estado brasileiro. Lembre-se que os estados devem ser identificados como abbrev_state. ganhadores_2022 &lt;- tibble( abbrev_state = c(&quot;RS&quot;, &quot;SC&quot;, &quot;PR&quot;, &quot;SP&quot;, &quot;MG&quot;, &quot;RJ&quot;, &quot;ES&quot;, &quot;MS&quot;, &quot;MT&quot;, &quot;GO&quot;, &quot;DF&quot;, &quot;TO&quot;, &quot;RO&quot;, &quot;AC&quot;, &quot;AM&quot;, &quot;PA&quot;, &quot;AP&quot;, &quot;RR&quot;, &quot;MA&quot;, &quot;PI&quot;, &quot;CE&quot;, &quot;RN&quot;, &quot;PB&quot;, &quot;PE&quot;, &quot;AL&quot;, &quot;SE&quot;, &quot;BA&quot;), ganhador = c(&quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Lula&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;,&quot;Bolsonaro&quot;, &quot;Lula&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;)) Como já haviámos baixado o dados espaciais, não é necessário repetir o processo. Podemos ir diretamente para a etapa de integrá-los ao banco de dados eleitoral de 2022. ganhadores_2022 &lt;- left_join(mapa_brasil, ganhadores_2022, by = &quot;abbrev_state&quot;) Por fim, utilizamos o mesmo código da etapa anterior para gerar o mapa de 2022. ganhadores_2022 %&gt;% ggplot() + ## Gera o gráfico geom_sf(aes(fill = ganhador)) ## Identifica a coluna &quot;ganhador&quot; como fonte para colorir os estados Pronto! Temos nossa primeira história a ser contada. Ainda que existam diferenças, os mapas são muito parecidos. Ou seja, a distribuição geográfica dos votos da campanha vitoriosa de Dilma Rousseff em 2014 é muito parecida com aquela realizada por Lula da Silva em 2022. Os mapas mostram isto claramente! Agora, se tiver tempo, sugerimos que você faça os mapas para outras eleições presidenciais. Por exemplo, o que aconteceu em 1994 e 2002? "],["mapas-municipais.html", "Parte 3 Mapas municipais 3.1 Organização Intramunicipal 3.2 Importação das Bases 3.3 Preparação do Banco de Dados 3.4 Visualização do mapa", " Parte 3 Mapas municipais 3.1 Organização Intramunicipal Administrativamente, a Justiça Eleitoral se organiza em zonas eleitorais, nas quais estão localizados os locais de votação, que abrigam as seções eleitorais (sendo que cada seção eleitoral corresponde a uma urna). Dentro dos municípios, porém, a organização territorial da Justiça Eleitoral não coincide necessariamente com outras divisões administrativas. Ou seja, os limites das zonas eleitorais muitas vezes não correspondem aos limites de bairros ou distritos. Além disso, os Tribunais Regionais Eleitorais (TREs) não têm o costume de divulgar arquivos espaciais que apresentem os limites dessas zonas. Então, como produzir mapas de resultados eleitorais dentro de municípios? Para isso, utilizamos outra fonte de dados do Tribunal Superior Eleitoral (TSE). O TSE divulga os endereços de todos os locais de votação brasileiros e as suas seções eleitorais correspondentes de todas as disputas desde 2008 (alguns TREs divulgam essas informações para eleições prévias a 2008) e podem ser usadas para esse fim. Esses registros administrativos têm, inclusive, uma coluna com a informação de bairro desse endereço. Bastaria então unir o banco de resultados por seção eleitoral com esse de locais de votação, somar os votos no bairro informado pela coluna dos registros do TSE, acoplar os resultados num mapa e pronto, certo? Infelizmente, não. A informação do bairro advinda dos registros do TSE frequentemente não coincide com o bairro onde geograficamente está esse local de votação (para mais informações, veja Gelape, 2017, 2018). Assim, para produzirmos mapas com votações de candidatos dentro de um município, precisamos encontrar a localização dos locais de votação no espaço. Neste exercício, utilizamos um banco de dados disponibilizado pelo prof. Daniel Hidalgo (do Massachusetts Institute of Technology, MIT) que cataloga a latitude e longitude para os locais de votação brasileiros entre 2006 e 2020. Esse foi um esforço de pesquisa que cruzou diferentes fontes de dados para determinar as coordenadas geográficas e que contou com a participação do FGV-CEPESP (para mais informações, deem uma olhada no repositório do GitHub – e na documentação da metodologia deste processo). Com a latitude e longitude, podemos cruzar essa informação espacial com outra(s) informações espaciais, como um mapa de bairros de um município, para passar aos nossos pontos (isto é, os locais de votação) tais informações. 3.2 Importação das Bases Neste exercício, prepararemos um mapa da cidade de São Paulo contendo os dados de votação por seção eleitoral do candidato a prefeito Guilherme Boulos (PSOL) em 2020. Nosso primeiro passo, como no exercício anterior, será carregar os pacotes relevantes para a nossa análise. O pacote tidyverse carrega diversos pacotes importantes, como alguns já utilizados anteriormente, como o ggplot2 e o dplyr. Também carregamos novamente os pacotes sf e geobr. Temos, no entanto, três novidades. Primeiro, o ggspatial nos ajudar a plotar mapas mais detalhados (de certa maneira, ele é utilizado em conjunto com o ggplot2). O classInt nos ajuda a dividir distribuições de dados, para preparar escalas de cores de um mapa, por exemplo. Por fim, o pacote cartography ajuda a produzir mapas temáticos, com mais funcionalidades para essa tarefa. library(tidyverse) library(sf) library(geobr) library(ggspatial) library(classInt) library(cartography) Agora que já temos os pacotes carregados, vamos baixar os bancos de dados (todos preparados em formato RDS). Em primeiro lugar, baixamos a base de dados contendo dados de votacao por secao eleitoral do candidato a prefeito Guilherme Boulos (PSOL), e dos candidatos a vereador Milton Leite (DEM), Fernando Holiday (PATRIOTA) e Eduardo Suplicy (PT). Ela está salva como base2020.rds. Para facilitar nossa análise, aproveitamos o mesmo bloco de código para encurtar os nomes de cada um destes candidatos. Para tal, utilizamos as funções mutate e case_when do pacote dplyr. candsp2020 &lt;- readRDS(&quot;base/base2020_sp.rds&quot;) |&gt; mutate(nm_votavel = case_when( nm_votavel == &quot;MILTON LEITE DA SILVA&quot; ~ &quot;Milton Leite&quot;, nm_votavel == &quot;GUILHERME CASTRO BOULOS&quot; ~ &quot;Boulos&quot;, nm_votavel == &quot;EDUARDO MATARAZZO SUPLICY&quot; ~ &quot;Suplicy&quot;, nm_votavel == &quot;FERNANDO HOLIDAY SILVA BISPO&quot; ~ &quot;Holiday&quot;)) Para se ter ideia de seu conteúdo, apresentamos sua head abaixo. São 28 colunas (variáveis) e 80.984 linhas (observações) contendo o número de votos que cada um dos três candidatos obteve na eleição de 2020, sendo Boulos para prefeito e os demais para vereador. head(candsp2020) ## # A tibble: 6 × 13 ## dt_geracao ano_eleicao nr_turno sg_uf nm_municipio cd_municipio nr_zona nr_secao nr_local_votacao ds_cargo nm_votavel ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 21/12/2020 2020 1 SP SÃO PAULO 71072 408 242 1180 Vereador Suplicy ## 2 21/12/2020 2020 1 SP SÃO PAULO 71072 346 408 1309 Vereador Milton Leite ## 3 21/12/2020 2020 1 SP SÃO PAULO 71072 346 408 1309 Vereador Holiday ## 4 21/12/2020 2020 1 SP SÃO PAULO 71072 408 255 1198 Vereador Suplicy ## 5 21/12/2020 2020 1 SP SÃO PAULO 71072 408 255 1198 Vereador Holiday ## 6 21/12/2020 2020 1 SP SÃO PAULO 71072 408 255 1198 Prefeito Boulos ## # ℹ 2 more variables: qt_votos &lt;dbl&gt;, votos_validos_secao &lt;dbl&gt; Nosso próximo passo é carregar a base com dados geolocalizados de cada um dos locais de votação no município de São Paulo. Seu nome é lvsp2020.rds. lvsp2020 &lt;- readRDS(&quot;base/lvsp2020.rds&quot;) Ao abrir esta base de dados, você verá o endereço de cada local de votação (por ex., o Colégio Objetivo na Av. Paulista, 900, Bela Vista), acompanhado de sua longitude e latitude, além de outros dados espaciais. A base possui 2.063 observações e 19 variáveis. head(lvsp2020) ## # A tibble: 6 × 19 ## local_id ano sg_uf cd_localidade_tse cod_localidade_ibge nr_zona nr_locvot nr_cep nm_localidade nm_locvot ds_endereco ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 678500 2020 SP 71072 3550308 1 1015 1.31e6 SÃO PAULO COLÉGIO … AV. PAULIS… ## 2 670114 2020 SP 71072 3550308 2 1015 5.00e6 SÃO PAULO COLÉGIO … AV. FRANCI… ## 3 688691 2020 SP 71072 3550308 4 1015 3.10e6 SÃO PAULO EE. PROF… RUA DA MOÓ… ## 4 694622 2020 SP 71072 3550308 5 1015 1.43e6 SÃO PAULO CLUBE AT… RUA ESTADO… ## 5 696661 2020 SP 71072 3550308 6 1015 4.12e6 SÃO PAULO EE. MARE… RUA DONA J… ## 6 674162 2020 SP 71072 3550308 246 1015 4.75e6 SÃO PAULO EE. PROF… AVENIDA MÁ… ## # ℹ 8 more variables: ds_bairro &lt;chr&gt;, pred_long &lt;dbl&gt;, pred_lat &lt;dbl&gt;, pred_dist &lt;dbl&gt;, tse_lat &lt;dbl&gt;, tse_long &lt;dbl&gt;, ## # long &lt;dbl&gt;, lat &lt;dbl&gt; Nosso próximo passo será converter os dados de longitude (long) e latitude (lat) utilizando o pacote sf em um objeto de features espaciais. Isto é importante para compatibilizar a estrutura dos dados com os pacotes e mapas com os quais estamos trabalhando. Mais especificamente, a transformação tem por objetivo utilizar transformar esses dados tabulares em dados espaciais, produzidos com base no sistema de referência de coordenadas (CRS) geográficas SIRGAS 2000. Este passo é padrão para a elaboração da maioria dos mapas brasileiros. lvsp2020 &lt;- lvsp2020 |&gt; # Convertendo o dataframe &#39;lvsp2020&#39; em um objeto de features espaciais (&#39;sf&#39;) st_as_sf( coords = c(&quot;long&quot;, &quot;lat&quot;), # Define as colunas &#39;long&#39; e &#39;lat&#39; como coordenadas crs = 4674 # Define o sistema de referência de coordenadas (CRS) como 4674 - SIRGAS 2000 ) Pronto! Já temos os locais de votação e quantos votos os candidatos obtiveram em cada um urna. Temos, no entanto, um desafio. Havíamos falado que a Justiça Eleitoral se organiza por zonas eleitorais mas os limites destas zonas geralmente não são divulgados pelos TREs (e aquele bairro informado nos dados não necessariamente corresponde à divisão administrativa da cidade!). O que nós faremos, então, é utilizar outra delimitação espacial como “aproximação” para apresentar a distribuição dos votos no município de São Paulo. Uma estratégia possível é identificar o distrito (a menor agregação administrativa oficial do município de São Paulo) onde se encontra cada local de votação dessa cidade. Na base de dados mapas_distritos_sp.rds temos os mapas dos 96 distritos deste município. Por isso, iremos carregá-la agora. mapa &lt;- readRDS(&quot;base/mapa_distritos_sp.rds&quot;) Esta base se parece com aquelas que chamamos de mapa_brasil na parte anterior deste workshop. Para cada um dos distritos (coluna name_district), ela possui uma coluna chamada geom com a informação do polígono que representa o território do distrito. Veja abaixo como fica um mapa simples no qual utilizamos estes polígonos para plotar os distritos na cidade de São Paulo. # Pre-visualização do mapa de distritos de Sao Paulo usando ggplot2 ggplot(mapa) + # Adiciona camadas de features espaciais ao gráfico geom_sf() Agora, vamos visualizar onde fica cada um dos locais de votação do município de São Paulo. No código abaixo, utilizamos o ggplot2 para plotar o mapa com os distritos. Depois, com o comando geom_sf(data = lvsp2020), adicionamos uma nova camada ao nosso plot, agora com os locais de votação. Por fim, o theme_void() ajusta o layout do gráfico para facilitar a visualização. ggplot(mapa) + # Gera gráfico utilizando a base mapa geom_sf() + # Transforma em gráfico geoespacial geom_sf(data = lvsp2020) + # Adiciona camada com pontos dos locais de votação theme_void() # Ajusta o layout do gráfico deixando a tela de fundo em branco 3.3 Preparação do Banco de Dados Na etapa anterior, visualizamos alguns dos dados que utilizaremos para produzir alguns dos mapas eleitorais desse workshop. A partir de agora, vamos preparar os dados do candidato Guilherme Boulos para visualizar a sua votação por distritos de São Paulo. O primeiro passo será gerar uma base candsp2020_porlv na qual mantemos apenas o candidato Boulos e somamos a quantidade de votos obtidas em todas as urnas de cada local de votação. Note que você pode realizar o mesmo procedimento para outros candidatos. Para tal, basta substituir “Boulos” pelo nome do seu candidato de escolha. Lembre-se que as possibilidades nesse workshop são Milton Leite, Suplicy e Holiday. # Calcula votos por local de votacao candsp2020_porlv &lt;- candsp2020 |&gt; # Filtra somente pelo Boulos filter(nm_votavel == &quot;Boulos&quot;) |&gt; # Soma os votos do candidato e total da urna por local de votacao group_by(nr_zona, nr_local_votacao, nm_votavel) |&gt; summarise(votos_cand = sum(qt_votos), votos_validos = sum(votos_validos_secao)) |&gt; ungroup() |&gt; # Calcula o percencual de votos por local mutate(votos_cand_porc = round(votos_cand/votos_validos*100,1)) No exercício do mapa do Brasil, utilizamos o comando left_join para integrar a base de dados com os ganhadores em cada estado com a base que possuia os polígonos de cada estado (a coluna geom). Agora faremos algo muito parecido. Integraremos a base que acabamos de criar (candsp2020_porlv) a base que possui os locais de votação (lvsp2020). Para tal, também renomeamos o nr_local_votacao para nr_locvot a fim de assegurar que esta coluna tem o mesmo nome em ambas as bases. Por fim, transformamos as informações em objeto espacial com a função st_as_sf. # Une com a base de LV geolocalizado candsp2020_porlv &lt;- candsp2020_porlv |&gt; # Renomeia a variavel nr_local_votacao para facilitar o join rename(nr_locvot = nr_local_votacao) |&gt; # Traz a informacao da base de LV geolocalizado left_join(lvsp2020, by = c(&quot;nr_zona&quot;, &quot;nr_locvot&quot;)) |&gt; # Transforma em objeto espacial st_as_sf(sf_column_name = &quot;geometry&quot;) Pronto! Agora vamos gerar nosso primeiro mapa para pré-visualizar o que fizemos até aqui. A função é muito parecida com as que já utilizamos nos exercícios anteriores. O ggplot() carrega o gráfico, o primeiro geom_sf() informa a base com os polígonos e, na linha seguinte, informa que a coluna votos_cand_porc deve ser utilizada para estimar o tamanho (size) do pontos (quanto mais votos, maiores serão) e a cor (color) dos pontos (quanto mais votos, mais claro é a tonalidade do azul). # Pré-visualização dos votos dos candidatos por local de votação candsp2020_porlv |&gt; filter(nm_votavel == &quot;Boulos&quot;) |&gt; ggplot() + geom_sf(data=mapa)+ geom_sf(aes(size=votos_cand_porc, color=votos_cand_porc))+ theme_void() Note que neste mapa, os locais de votação estão em sua localização original. Ainda não geramos uma base na qual eles são inseridos dentro dos distritos. Para tal, utilizaremos o comando st_join() (spatial join) para integrar a base de locais de votação (lvsp2020) ao mapa. A função st_join() realiza um procedimento semelhante a um left_join(). Porém, ao invés de termos uma “variável-chave” que permitirá combinar as bases, a variável-chave é a sua localização no espaço! Ou seja, no exemplo abaixo, lvsp2020_distrito será um objeto espacial em que cada linha é um local de votação (ponto) ao qual foram adicionadas novas colunas, cujos valores se referem ao distrito (polígono) no qual ele se encontra. # Faz o spatial join lvsp2020_distrito &lt;- st_join(lvsp2020, mapa) Existe, no entanto, um cuidado. Lembre-se que estamos fazendo uma reposição “artificial”. Isto é, os locais de votação não foram feitos para se enquadrarem perfeitamente nos distritos de São Paulo. O TRE tem sua própria distribuição espacial que não necessariamente bate com aquela do IBGE. Utilizando o comando nrow(), verificamos que a base lvsp2020_distrito tem uma linha a mais que a base lvsp2020! Ou seja, 2.064 linhas comparado com 2.063. nrow(lvsp2020) ## [1] 2063 nrow(lvsp2020_distrito) # Ele tem uma linha a mais! ## [1] 2064 O gráfico que geramos abaixo nos auxilia na identificação do problema. Existe um local de votação que está localizado exatamente na divisa entre Vila Mariana e Bela Vista. Por isso, os nosso trabalho de integrar bases de dados acabou gerando o mesmo local de votação duas vezes – uma para cada bairro. # Isso ocorreu porque um LV está bem na divisa entre dois distritos ggplot() + geom_sf(data=mapa %&gt;% filter(name_district %in% c(&quot;Vila Mariana&quot;, &quot;Bela Vista&quot;)))+ geom_sf(data = lvsp2020 |&gt; slice(269), size=2)+ theme_void() Existem várias soluções possíveis para este problema. Perceba que não necessariamente existirá a solução perfeita para todos os casos. É necessário refletir sobre o objetivo da análise. Primeiro, poderíamos escolher aleatoriamente onde colocar este local de votação (Vila Mariana ou Bela Vista). Copiamos abaixo o bloco de código que permitirá realizar esta modificação. # Possivel solução: selecionar aleatoriamente o bairro ao qual ele esta atribuido #lvsp2020_distrito &lt;- lvsp2020_distrito |&gt; # group_by(nr_locvot, nr_zona) |&gt; # slice_sample(n = 1) |&gt; # ungroup() |&gt; # # Seleciona so as variaveis que vamos usar para o mapa # select(nr_zona, nr_locvot, name_district) |&gt; # # Retira a geometria, para ela ser tratada como uma tabela # st_drop_geometry() #nrow(lvsp2020_distrito) # 2.063 linhas, pronto! Para este exercício, selecionamos uma outra solução. Decidimos criar um comando geral que faz com que sempre que existirem mais de um ponto, o primeiro deles será escolhido. # Escolher o primeiro ponto lvsp2020_distrito &lt;- lvsp2020_distrito |&gt; group_by(nr_locvot, nr_zona) |&gt; slice(1) |&gt; ungroup() |&gt; # Seleciona so as variaveis que vamos usar para o mapa select(nr_zona, nr_locvot, name_district) |&gt; # Retira a geometria, para ela ser tratada como uma tabela st_drop_geometry() #nrow(lvsp2020_distrito) # 2.063 linhas, pronto! Da mesma forma que criamos uma base com votos por local de votação (candsp2020_porlv), agora criamos uma base que terá os votos por distrito (candsp2020_pordist). Lembre-se que isto foi possível porque compatibilizamos ambas as localizações geográficas. Para melhorar a visualização dos dados, calculamos na coluna votos_cand_porc a porcentagem dos votos que o candidato Boulos recebeu em cada distrito. # agregação dos votos nos locais de votação por distrito candsp2020_pordist &lt;- candsp2020_porlv |&gt; # Retira a informacao da geometria dos pontos st_drop_geometry() |&gt; # Traz a informacao do distrito referente ao ponto, que obtivemos acima left_join(lvsp2020_distrito, by = c(&quot;nr_zona&quot;, &quot;nr_locvot&quot;)) # Soma os votos do candidato por distrito e calcula o % candsp2020_pordist &lt;- candsp2020_pordist |&gt; group_by(name_district, nm_votavel) |&gt; summarise(votos_cand = sum(votos_cand), votos_validos = sum(votos_validos)) |&gt; ungroup() |&gt; mutate(votos_cand_porc = round(votos_cand/votos_validos*100,1)) Por fim, geramos um objeto espacial integrando com o comando left_join a base geoespacial mapa à base eleitoral candsp2020_pordist com base na coluna name_district que define o nome dos distritos. Ou seja, queremos saber associar a votação de Boulos em cada distrito a um objeto com as informações espaciais desses distritos. # Cria um objeto espacial em que passamos para o mapa a votacao # de Boulos em cada um dos distritos de SP boulos_final &lt;- left_join(mapa, candsp2020_pordist, by = c(&quot;name_district&quot;)) Pronto! Agora já podemos pré-visualizar o mapa de votação do Boulos por distrito de São Paulo! Mais uma vez, utilizamos o comando ggplot() para gerar o gráfico e, dentro do comando geom_sf, utilizamos o argumento fill para preencher cada distrito com tonalidades diferentes de acordo com a porcentagem de votos obtida pelo candidato selecionado (votos_cand_porc). # Pré-visualização dos votos dos candidatos por distrito boulos_final |&gt; ggplot() + geom_sf(aes(fill = votos_cand_porc)) + theme_void() 3.4 Visualização do mapa Por fim, vamos melhorar substancialmente diversos aspectos do nosso mapa. Existem diversas escalas para definir os cortes de uma variável, que vão informar como colorir áreas de um mapa. Para mais informações, veja este vídeo no YouTube. Ele está em inglês, mas é possível gerar legendas traduzidas automaticamente. Vejamos como ao escolher duas delas, e produziremos dois mapas que sugerem informações diferentes fundamentados na mesma base de dados. Testaremos abaixo a abordagem de Cortes de Jenks (jenks) e Intervalos Geogmétricos (geom). O corte de jenks é feito com o pacote classIntervals. Note que ao fim do comando, identificamos o tipo de corte. # Cria os cortes e os guardamos em um objeto cortes &lt;- classIntervals(boulos_final$votos_cand_porc, 4, &quot;jenks&quot;) # Cria uma variável com os cortes boulos_final$cortes_jenks &lt;- cut(boulos_final$votos_cand_porc, cortes$brks, include.lowest = T) Agora realizamos um procedimento muito parecido para gerar os intervalos geométricos. Para tal, substituímos jenks por geom. # Cria os cortes e os guardamos em um objeto cortes &lt;- getBreaks(boulos_final$votos_cand_porc, 4, &quot;geom&quot;) # Insere os cortes na base de dados usando a função cut boulos_final$int_geom &lt;- cut(boulos_final$votos_cand_porc, cortes, include.lowest = T) Agora, faremos a visualização de ambos os cortes. Começamos pelo jenks. # Visualização do corte jenks ggplot() + geom_sf(data=boulos_final, aes(fill=cortes_jenks))+ scale_fill_brewer(palette = &quot;RdBu&quot;, name=&quot;Votação (%)&quot;)+ theme_void() O código apresentado logo abaixo gera o mesmo mapa utilizando os cortes geom. Note na legenda que os cortes são consideravelmente diferentes. Isto leva a apresentação de gráficos com cores igualmente diferentes. Compare as diferentes regiões da cidade. É visível que, dependendo do corte, o mapa pode acabar contando uma história diferente. Portanto, é importante refletir antes de decidir qual corte será utilizado. Mais uma vez, não existe solução perfeita. # Visualização do corte geom ggplot() + geom_sf(data=boulos_final, aes(fill=int_geom))+ scale_fill_brewer(palette = &quot;RdBu&quot;, name=&quot;Votação (%)&quot;)+ theme_void() Em boa parte dos casos, porém, você vai querer criar uma escala a partir dos resultados observados. Por exemplo, em vez do corte elaborado pela metodologia de intervalos geométricos, que gerou uma categoria variando entre 11,6% e 14,9%, talvez você queira um corte indo de 10,0% até 15,0%. No código abaixo, criamos uma escala manualmente com intervalos de 5 p.p. em 5 p.p., iniciando em 10. Além disso, incluímos diversos elementos, como título, legenda, escala, e rosa dos ventos. Você poderá ver como modificar cada um destes elementos a partir dos comentários que inserimos no bloco de código. Como você perceberá, o resultado final parece muito mais profissional (e agradável aos olhos) que os mapas gerados nos exercícios anteriores. # A partir do objeto espacial boulos_final |&gt; # Cria uma variável categórica e preenche os níveis que serão a legenda mutate( categoria = case_when( is.na(votos_cand_porc) ~ &quot;Sem LV&quot;, votos_cand_porc &gt; 10 &amp; votos_cand_porc &lt;= 15 ~ &quot;10-15%&quot;, votos_cand_porc &gt; 15 &amp; votos_cand_porc &lt;= 20 ~ &quot;15-20%&quot;, votos_cand_porc &gt; 20 &amp; votos_cand_porc &lt;= 25 ~ &quot;20-25%&quot;, votos_cand_porc &gt; 25 &amp; votos_cand_porc &lt;= 30 ~ &quot;25-30%&quot;, votos_cand_porc &gt; 30 ~ &quot;&gt;30%&quot;), categoria = factor( categoria, levels = c(&quot;Sem LV&quot;, &quot;10-15%&quot;, &quot;15-20%&quot;, &quot;20-25%&quot;, &quot;25-30%&quot;, &quot;&gt;30%&quot;))) |&gt; # Inicia o ggplot ggplot() + # Usa uma camada de sf geom_sf(aes(fill = categoria), color = &quot;black&quot;, size = 0.1) + # Retira o datum coord_sf(datum = NA) + # Coloca o fill na paleta de verdes scale_fill_brewer(palette = &quot;YlOrBr&quot;) + # Adicionar título, subtítulo e legenda labs( title = &quot;Votação de Guilherme Boulos (2020, 1º turno)&quot;, subtitle = &quot;Distritos do município do SP&quot;, caption = &quot;Fonte: Elaborado por Gelape, Guedes Neto e Faganello (2023), a partir de\\ndados do TSE, Hidalgo e IBGE.&quot;) + # Adiciona escala ggspatial::annotation_scale( location = &quot;br&quot;, width_hint = 0.4, line_width = 0.5, height = unit(0.1,&quot;cm&quot;)) + # Coloca título na legenda guides(fill = guide_legend(title = &quot;Votos válidos (%)&quot;)) + # Ajusta elementos do tema do ggplot theme( # Posição e direção da legenda legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;, # Centralização de alguns elementos textuais plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5), plot.caption = element_text(hjust = 0.5)) + # Adiciona rosa-dos-ventos ggspatial::annotation_north_arrow( location = &quot;br&quot;, which_north = &quot;true&quot;, style = north_arrow_fancy_orienteering(), # Ajusta a altura da rosa-dos-ventos (pode exigir tentativa e erro) pad_x = unit(0.5, &quot;cm&quot;), pad_y = unit(1, &quot;cm&quot;)) "],["atividades-extras.html", "Parte 4 Atividades Extras 4.1 Marta Suplicy em 2000 4.2 Eduardo Paes em 2020", " Parte 4 Atividades Extras 4.1 Marta Suplicy em 2000 Nosso primeiro passo é sempre carregar os pacotes que são relevantes para o nosso trabalho. A única novidade em relação aos exercícios anteriores é o pacote RColorBrewer. Já que queremos plotar mapas bonitos, ele nos auxília com uma série de paletas de cores adicionais. library(dplyr) library(tidyr) library(sf) library(ggplot2) library(ggspatial) library(RColorBrewer) Os procedimentos iniciais são muito parecidos com o que realizamos para as tarefas anteriores. Começamos baixando a base de dados que possui os resultados por local de votação na cidade de São Paulo no ano 2000 (nomeada lv2000). Além dela, também importaremos o mapa de distritos de São Paulo (mapa). # Importa os dados de resultado por local de votação em SP lv2000 &lt;- readRDS(&quot;base/base2000_sp.rds&quot;) # Importa o mapa de distritos de São Paulo mapa &lt;- readRDS(&quot;base/mapa_distritos_sp.rds&quot;) Agora identificaremos o total de votos por local de votação. Note que a base lv2000 do CEM/USP já contém os dados de votação dos candidatos a prefeito. Nela, as colunas com os dados de votação seguem o seguinte padrão: PF00_111. Neste padrão: PF indica votação para prefeito; o primeiro dígito depois de “_” indica o turno; os dois números seguintes indicam o número do prefeito. A coluna com a votação da Marta Suplicy no primeiro turno, portanto, é PF00_113. Para mais informações, consulte a documentação preparada pelos pesquisadores do CEM/USP. # Obtenção do total de votos validos para prefeito por local de votação votos_pref &lt;- lv2000 |&gt; # Remove as colunas de geometria espacial st_drop_geometry() |&gt; # Seleciona as colunas &#39;ID&#39; e um intervalo de colunas de &#39;PF00_111&#39; a &#39;PF00_156&#39; select(ID, PF00_111:PF00_156) |&gt; # Transforma as colunas de votos em linhas pivot_longer(cols = c(PF00_111:PF00_156), names_to = &quot;coluna&quot;, values_to = &quot;voto&quot;) |&gt; # Substitui valores NA em &#39;voto&#39; por 0 mutate(voto = replace_na(voto, 0)) |&gt; # Cria uma nova coluna &#39;voto_total&#39; que é a soma dos votos por &#39;ID&#39; group_by(ID) |&gt; summarise(voto_total = sum(voto)) |&gt; ungroup() Nosso próximo passo, mais uma vez, é usar o comando left_join para integrar a base de dados de locais de votação (lv2000) com a de votos para prefeita (votos_pref) e selecionar apenas os votos da candidata Marta Suplicy. Chamaremos esta nova base de lv2000_2. # Cria um novo tibble &#39;lv2000_2&#39; a partir do &#39;lv2000&#39; lv2000_2 &lt;- lv2000 |&gt; # Combina &#39;lv2000&#39; com &#39;votos_pref&#39; usando um leftjoin pelo &#39;ID&#39; left_join(votos_pref, by = &quot;ID&quot;) |&gt; # Seleciona as colunas &#39;ID&#39;, &#39;PF00_113&#39; e &#39;voto_total&#39; select(ID, PF00_113, voto_total) Agora integraremos a base de LV (ponto) com seus respectivos distritos (polígonos). Para tanto, utilizamos o comando de spatial join (st_join). mapa_unificado &lt;- st_join(mapa, lv2000_2) Por que mapa_unificado agora tem 1.135 linhas e não 1.134? Dica: investigue o distrito (em mapa) de Marsilac no extremo sul da cidade. Nosso próximo passo será agrupar as votações da candidata por distrito e, como fizemos anteriormente, calcular a proporção de votos para cada uma destas localidades. # Usa o tibble &#39;mapa_unificado&#39; mapa_final &lt;- mapa_unificado |&gt; # Calcula a soma total dos votos para &#39;Marta&#39; e no total em cada distrito group_by(name_district) |&gt; summarise(marta = sum(PF00_113), voto_total = sum(voto_total)) |&gt; ungroup() |&gt; # Calcula a porcentagem de votos para &#39;Marta&#39; e arredonda para 1 casa decimal mutate(porc = round(marta/voto_total*100, 1)) Agora precisamos decidir como vamos agrupar os dados para preparar a legenda do nosso gráfico. Ela indica como será feita a escala de cores para o nosso gráfico. Uma dica é retornar a discussão sobre Cortes de Jenks que realizamos no exercício anterior. Para este novo mapa, utilizaremos as seguintes categorias: “25-31%”, “31-37%”, “37-43%”, e “43-49%”. # Cria uma variavel categorica para melhorar a visualizacao mapa_final &lt;- mutate( mapa_final, voto_cat = case_when( is.na(porc) ~ &quot;Sem LV&quot;, TRUE ~ cut(porc, seq(25, 49, 6), labels = c(&quot;25-31%&quot;, &quot;31-37%&quot;, &quot;37-43%&quot;, &quot;43-49%&quot;)))) Por fim, utilizaremos todos estes dados para produzir o gráfico final com a distribuição de votos (proporcional por distrito) da Marta Suplicy na eleição para prefeita no ano 2000. # Monta uma string de cores. cores &lt;- brewer.pal(4, &quot;OrRd&quot;) cores &lt;- c(cores, &quot;#999999&quot;) # Inicia o ggplot mapa_final |&gt; ggplot() + # Usa uma camada de sf geom_sf(aes(fill = voto_cat), color = &quot;black&quot;, size = 0.1) + # Retira o datum theme_void() + # Coloca o fill na paleta de verdes scale_fill_manual(values = cores) + # Adicionar titulo, subtitulo e legenda labs( title = &quot;Votação de Marta Suplicy (2000, 1º turno)&quot;, subtitle = &quot;Distritos do município de São Paulo&quot;, caption = &quot;Fonte: Elaborado a partir de\\ndados do CEM e IBGE.&quot;) + # Adiciona escala ggspatial::annotation_scale( location = &quot;br&quot;, width_hint = 0.4, line_width = 0.5, height = unit(0.1,&quot;cm&quot;)) + # Coloca titulo na legenda guides(fill = guide_legend(title = &quot;Votos válidos&quot;)) + # Ajusta elementos do tema do ggplot theme( # Posicao e direcao da legenda legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;, # Centralizacao de alguns elementos textuais plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5), plot.caption = element_text(hjust = 0.5)) + # Adiciona rosa-dos-ventos ggspatial::annotation_north_arrow( location = &quot;br&quot;, which_north = &quot;true&quot;, style = north_arrow_fancy_orienteering(), # Ajusta a altura da rosa-dos-ventos (pode exigir tentativa e erro) pad_x = unit(0.5, &quot;cm&quot;), pad_y = unit(1, &quot;cm&quot;)) 4.2 Eduardo Paes em 2020 Para o caso do Rio de Janeiro, utilizaremos alguns pacotes que não foram necessários para os exercícios anteriores. Descrevemos cada um deles brevemente no código apresentado abaixo. library(here) # Parecido com o setwd() mas com funções adicionais para referenciar arquivos library(dplyr) # Gramática para manipular dados library(readr) # Pacote para abrir bases, por ex., em CSV library(stringr) # Facilita a manipulação de variáveis &quot;string&quot; library(janitor) # Auxilia na limpeza dos dados library(sf) # Manipulação de dados espaciais library(geobr) # Pacote com mapas do Brasil library(ggplot2) # Pacote para elaboração de gráficos library(ggspatial) # Complementar ao ggplot2, com foco em mapas Como nos outros exercícios, vamos importar a base com (1) locais de votação do município do Rio de Janeiro em 2020, (2) os dados eleitorais do candidato a prefeitura Eduardo Paes (PSD) e (3) a localização dos setores censitários da cidade (para extrair a informação dos seus bairros, posteriormente). # Leitura da base dos locais de votação no Rio em 2020 lvrj &lt;- readRDS(&quot;base/lvrj2020.rds&quot;) # Leitura da base com dados eleitorais de Eduardo Paes paes2020 &lt;- readRDS(&quot;base/base2020_rj.rds&quot;) # Lendo o mapa de setores censitários do Rio de Janeiro rj_sc &lt;- readRDS(&quot;base/mapa_setores_rj.rds&quot;) Neste próximo bloco de código, vamos unir as informações de bairro “corretas” ao banco de dados de locais de votação. Lembre-se que, como discutimos anteriormente, as zonas eleitorais do TRE não são equivalentes à distribuição espacial dos setores censitários. Além disso, não se esqueça de informar que o CRS é do SIRGAS 2000 (código 4674). # Transforma lvrj em um objeto espacial lvrj_espacial &lt;- lvrj |&gt; # Remove os NA, se houver (importante checar quantos NA, se for o caso) filter(!is.na(long)) |&gt; # Objeto com crs = 4674 (Sirgas2000) st_as_sf(coords = c(&quot;long&quot;, &quot;lat&quot;), crs = 4674) Nosso próximo passo é utilizar o comando st_join, como nos exemplos anteriores, para integrar os dados espaciais de lvrj_espacial e rj_sc. # Faz o spatial join lvrj_espacial &lt;- st_join(lvrj_espacial, rj_sc) Antes de prosseguir, vamos verificar se o número de NAs (dados ausentes) é muito grande. O que encontraremos, como você perceberá, é que não existe nenhum “missing” nas 1.422 linhas da tabela para a coluna NM_MUNICIP. Ou seja, todos os locais de votação (pontos) encontraram um setor censitário (polígono) correspondente. # Checa número de NAs (0 de 1.422) table(is.na(lvrj_espacial$NM_MUNICIP)) ## ## FALSE ## 1422 Agora já podemos agregar os votos por bairro do município do Rio de Janeiro. Começamos pela remoção dos atributos espaciais do banco de locais de votação e, logo em seguida, integramos as bases voto por seção com os locais de votação atualizados. # Remove atributos espaciais do banco de LVs lvrj &lt;- st_drop_geometry(lvrj_espacial) # Unir os bancos de voto-secao com os de LVs atualizados paes2020_lv &lt;- paes2020 |&gt; # Agrupa os votos do Paes por LV group_by(dt_geracao, ano_eleicao, nr_turno, sg_uf, nm_municipio, cd_municipio, nr_zona, nr_local_votacao, ds_cargo, nm_votavel) |&gt; summarise(qt_votos = sum(qt_votos), votos_validos_lv = sum(votos_validos_secao)) |&gt; ungroup() |&gt; # Junta com o banco de LV left_join(lvrj, by = c(&quot;cd_municipio&quot; = &quot;cd_localidade_tse&quot;, &quot;nr_zona&quot;, &quot;nr_local_votacao&quot; = &quot;nr_locvot&quot;, &quot;ano_eleicao&quot; = &quot;ano&quot;)) Isto nos permitirá agrupar os votos do candidato Eduardo Paes por bairro. Lembramos, mais uma vez, que isto é possível já que temos o endereço de cada local de votação e sua geolocalização. # Agrupa os votos do Paes por bairro paes2020_bairro &lt;- paes2020_lv |&gt; group_by(NM_BAIRRO, CD_GEOCODB) |&gt; summarise(qt_votos = sum(qt_votos), votos_validos_bairro = sum(votos_validos_lv)) |&gt; ungroup() Com base nestes dados, produzimos a proporção de votos que o candidato obteve em cada bairro. Pelo comando summary, verificamos que a média de Paes por bairro do Rio foi de 37,25%, sendo que não obteve mais que 51,86% em nenhum bairro no primeiro turno de 2020. # Preparar o banco de dados paes2020_bairro &lt;- paes2020_bairro |&gt; mutate(percentual = (qt_votos/votos_validos_bairro)*100) # Algumas estatisticas descritivas do percentual summary(paes2020_bairro$percentual) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 21.40 33.47 37.40 37.25 40.11 51.86 Nosso próximo passo será utilizar os mapas do pacote geobr (isto é, seu arquivo shp) para gerar um mapa de bairros mais “limpo” do que o que temos e integrar seus dados ao nosso tibble original. Os dados do geobr estão com uma duplicação de bairros. No caso, o mesmo bairro (Marechal Hermes) aparece em duas linhas do objeto espacial, sendo uma tendo como subdistrito Jacarepaguá e outra como Madureira. Para eliminar uma dessas linhas do banco (que duplicaria os votos nessa região ao fazermos o join), consultamos um mapa oficial de bairros do município do Rio de Janeiro e verificamos que Marechal Hermes está na Região Administrativa de Madureira, portanto vamos excluir do objeto a linha que se refere a Jacarepaguá. # Abre um shp de bairros mais &quot;limpo&quot; rj_bairros &lt;- read_neighborhood(showProgress = F) |&gt; # Filtra somente o municipio do RJ filter(name_muni == &quot;Rio De Janeiro&quot;) |&gt; # Cria coluna para identificar qual linha deve ser removida e a remove mutate(remover = ifelse(name_neighborhood == &quot;Marechal Hermes&quot; &amp; name_subdistrict == &quot;Jacarepaguá&quot;, T, F)) |&gt; filter(!remover) # Passa a info de votos pro shp rj_bairros_paes &lt;- rj_bairros |&gt; # Faremos o join somente por codigo do bairro, pois caso o fizessemos com o # nome do bairro, teriamos alguns casos sem combinacao exata, e produziriamos # falsos negativos (NA que nao sao NA na prática) left_join(paes2020_bairro, by = c(&quot;code_neighborhood&quot; = &quot;CD_GEOCODB&quot;)) Por fim, utilizamos estas informações para gerar o mapa com uma escala de percentuais que varia de 10 em 10 p.p. como apresentado abaixo na sequência do comando mutate. Note também que as funções do ggplot estão comentadas para te auxiliar na customização dos mapas. # A partir do objeto espacial rj_bairros_paes |&gt; # Cria uma variavel categoria e preenche os niveis, que serao a legenda mutate( categoria = case_when( is.na(percentual) ~ &quot;Sem LV&quot;, percentual &gt; 20 &amp; percentual &lt;= 30 ~ &quot;20-30%&quot;, percentual &gt; 30 &amp; percentual &lt;= 40 ~ &quot;30-40%&quot;, percentual &gt; 40 &amp; percentual &lt;= 50 ~ &quot;40-50%&quot;, percentual &gt; 50 ~ &quot;&gt;50%&quot;), categoria = factor( categoria, levels = c(&quot;Sem LV&quot;, &quot;20-30%&quot;, &quot;30-40%&quot;, &quot;40-50%&quot;, &quot;&gt;50%&quot;))) |&gt; # Inicia o ggplot ggplot() + # Usa uma camada de sf geom_sf(aes(fill = categoria), color = &quot;black&quot;, size = 0.1) + # Retira o datum coord_sf(datum = NA) + # Coloca o fill na paleta de verdes scale_fill_brewer(palette = &quot;Greens&quot;) + # Adicionar titulo, subtitulo e legenda labs( title = &quot;Votação de Eduardo Paes (2020, 1º turno)&quot;, subtitle = &quot;Bairros do município do RJ&quot;, caption = &quot;Fonte: Elaborado por Gelape, Guedes Neto e Faganello (2023), a partir de\\ndados do TSE, Hidalgo e IBGE.&quot;) + # Adiciona escala ggspatial::annotation_scale( location = &quot;br&quot;, width_hint = 0.4, line_width = 0.5, height = unit(0.1,&quot;cm&quot;)) + # Coloca titulo na legenda guides(fill = guide_legend(title = &quot;Votos válidos&quot;)) + # Ajusta elementos do tema do ggplot theme( # Posicao e direcao da legenda legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;, # Centralizacao de alguns elementos textuais plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5), plot.caption = element_text(hjust = 0.5)) + # Adiciona rosa-dos-ventos ggspatial::annotation_north_arrow( location = &quot;br&quot;, which_north = &quot;true&quot;, style = north_arrow_fancy_orienteering(), # Ajusta a altura da rosa-dos-ventos (pode exigir tentativa e erro) pad_x = unit(14, &quot;cm&quot;), pad_y = unit(6.5, &quot;cm&quot;)) "],["apêndice.html", "Parte 5 Apêndice 5.1 Resultados Eleitorais 5.2 Locais de Votação 5.3 Divisões Administrativas 5.4 Informações da sessão", " Parte 5 Apêndice Nesta parte, apresentamos o script utilizado para montar todas as bases de dados, espaciais ou não espaciais, utilizadas nesse workshop: resultados por seção eleitoral, coordenadas geográficas dos locais de votação e divisões administrativas de municípios brasileiros. library(here) library(dplyr) library(readr) library(janitor) library(electionsBR) library(sf) library(geobr) # Cria um diretorio para guardar as bases, caso ele nao exista if(!dir.exists(&quot;base/&quot;)) dir.create(&quot;base/&quot;) 5.1 Resultados Eleitorais 5.1.1 São Paulo em 2020 Votação por seção eleitoral dos candidatos Guilherme Boulos, Eduardo Suplicy, Fernando Holiday e Milton Leite na cidade de São Paulo em 2020. Fonte: TSE, via electionsBR. # Essa função está somente na versão em dev do electionsBR # https://github.com/silvadenisson/electionsBR base2020 &lt;- electionsBR::elections_tse(2020, &quot;vote_section&quot;, &quot;SP&quot;) # Prepara banco incluindo agregado de votos por secao base2020 &lt;- base2020 |&gt; # Filtra pelo município de SP, 1o turno e elimina brancos/nulos filter(NM_MUNICIPIO == &quot;SÃO PAULO&quot;, NR_TURNO == 1, !NR_VOTAVEL %in% c(95, 96)) |&gt; # Calcula o total de votos válidos por cargo/seção group_by(DS_CARGO, NR_ZONA, NR_SECAO) |&gt; mutate(votos_validos_secao = sum(QT_VOTOS)) |&gt; ungroup() |&gt; # Filtra pelos candidatos escolhidos filter(NM_VOTAVEL %in% c(&quot;GUILHERME CASTRO BOULOS&quot;, &quot;EDUARDO MATARAZZO SUPLICY&quot;, &quot;FERNANDO HOLIDAY SILVA BISPO&quot;, &quot;MILTON LEITE DA SILVA&quot;)) |&gt; # Seleciona variáveis de interesse select(DT_GERACAO, ANO_ELEICAO, NR_TURNO, SG_UF, NM_MUNICIPIO, CD_MUNICIPIO, NR_ZONA, NR_SECAO, NR_LOCAL_VOTACAO, DS_CARGO, NM_VOTAVEL, QT_VOTOS, votos_validos_secao) |&gt; # Limpa os nomes de variáveis clean_names() # Exporta o banco saveRDS(base2020, &quot;base/base2020_sp.rds&quot;) 5.1.2 Rio de Janeiro em 2020 Votação por seção eleitoral do candidato Eduardo Paes na cidade do Rio de Janeiro em 2020. Fonte: TSE, via electionsBR. # Baixa os dados de voto-seção base2020 &lt;- elections_tse(2020, &quot;vote_section&quot;, &quot;RJ&quot;) # Prepara banco incluindo agregado de votos por seção paes2020 &lt;- base2020 |&gt; # Filtra pelo municipio do RJ, 1o turno e elimina brancos/nulos filter(NM_MUNICIPIO == &quot;RIO DE JANEIRO&quot;, NR_TURNO == 1, !NR_VOTAVEL %in% c(95, 96)) |&gt; # Calcula o total de votos válidos por cargo/seção group_by(DS_CARGO, NR_ZONA, NR_SECAO) |&gt; mutate(votos_validos_secao = sum(QT_VOTOS)) |&gt; ungroup() |&gt; # Filtra pelo Eduardo Paes filter(NR_VOTAVEL == 25 &amp; DS_CARGO == &quot;Prefeito&quot;) |&gt; # Seleciona variáveis de interesse select(DT_GERACAO, ANO_ELEICAO, NR_TURNO, SG_UF, NM_MUNICIPIO, CD_MUNICIPIO, NR_ZONA, NR_SECAO, NR_LOCAL_VOTACAO, DS_CARGO, NM_VOTAVEL, QT_VOTOS, votos_validos_secao) |&gt; # Limpa os nomes de variáveis clean_names() # Exporta resultado saveRDS(paes2020, &quot;base/base2020_rj.rds&quot;) 5.1.3 São Paulo em 2000 Shapefile com os pontos dos locais de votação e resultados da eleição municipal de 2000. Fonte: CEM (Centro de Estudos da Métropole, USP). # Baixa o arquivo download.file( &quot;https://centrodametropole.fflch.usp.br/pt-br/file/18772/download?token=t4vNFXTg&quot;, destfile = &quot;base/EL2000_LV_RMSP_CEM_V2.zip&quot;) # Cria um diretorio temporario no computador dirtemp &lt;- tempdir() # Descompacta do arquivo contendo o shp na pasta temporária zipfile &lt;- unzip(&quot;base/EL2000_LV_RMSP_CEM_V2.zip&quot;, exdir = dirtemp) # Lê o shp com os pontos dos locais de votação e resultados eleitorais de 2000. lv2000 &lt;- st_read( zipfile[3], # Usamos o ENCODING=WINDOWS-1252 para ajustar os caracteres com acento options = &quot;ENCODING=WINDOWS-1252&quot;, crs = 4674) |&gt; # Filtra pontos da cidade de São Paulo. O mapa contém dados de toda a RMSP filter(MUN_NOME == &quot;SAO PAULO&quot;) # Exporta resultado saveRDS(lv2000, &quot;base/base2000_sp.rds&quot;) 5.2 Locais de Votação Os dados abaixo foram obtidos de um repositório do GitHub do Prof. Daniel Hidalgo (MIT). Este repositório disponibiliza os locais de votação com latitude e longitude entre 2006 e 2020 para todo o Brasil. #Baixa o arquivo produzido por Danny Hidalgo com todos os LV entre 2006-2020 download.file( &quot;https://github.com/fdhidalgo/geocode_br_polling_stations/releases/download/v0.13-beta/geocoded_polling_stations.csv.gz&quot;, here(&quot;base&quot;, &quot;geocoded_polling_stations.csv.gz&quot;)) # Abre os dados e filtra para o ano de 2020 baselv2020 &lt;- read_csv( here(&quot;base&quot;, &quot;geocoded_polling_stations.csv.gz&quot;)) |&gt; filter(ano == 2020) 5.2.1 São Paulo em 2020 Agora podemos filtrar os dados georeferenciados específicos para o município de São Paulo. # Filtra o municipio de São Paulo e mantem somente as variaveis de interesse baselv2020_sp &lt;- baselv2020 |&gt; filter(nm_localidade == &quot;SÃO PAULO&quot;) |&gt; # Mantem somente 1 nr_locvot por zona. Selecionamos aleatoriamente o escolhido group_by(nr_locvot, nr_zona) |&gt; slice_sample(n = 1) |&gt; ungroup() # n = 2.063 # Exporta banco em rds saveRDS(baselv2020_sp, &quot;base/baseLocais2020SP.rds&quot;) 5.2.2 Rio de Janeiro em 2020 Filtramos também os do Rio de Janeiro para 2020. # Filtra o municipio do RJ e mantem somente as variaveis de interesse baselv2020_rj &lt;- baselv2020 |&gt; filter(nm_localidade == &quot;RIO DE JANEIRO&quot;) |&gt; # Ignorando aleatoriamente aquelas que tem mais de 1 nr_locvot por zona group_by(nr_locvot, nr_zona) |&gt; slice_sample(n = 1) |&gt; ungroup() # n = 1.422 # Exporta banco em rds saveRDS(baselv2020_rj, &quot;base/lvrj2020.rds&quot;) 5.3 Divisões Administrativas 5.3.1 Distritos de São Paulo O shapefile com os polígonos referentes aos distritos do município de São Paulo foram obtidos pelo pacote geobr, que extrai esses dados do IBGE. # Mapa de polígonos dos distritos de São Paulo. Fonte: IBGE via geobr mapa_bairros &lt;- read_neighborhood(2010) sp_distritos &lt;- mapa_bairros |&gt; filter(name_muni == &quot;São Paulo&quot;) # Exporta o objeto espacial em rds saveRDS(sp_distritos, &quot;base/mapa_distritos_sp.rds&quot;) 5.3.2 Rio de Janeiro Para o caso do Rio de Janeiro, optamos por utilizar um shapefile com os setores censitários do município no ano de 2010 (que contém as informações dos bairros e subdistritos). A fonte dos dados também é o IBGE, e ele pode ser obtido na página de malha de setores censitários de 2010. # Mapa de polígonos dos setores censitários do Rio de Janeiro. rj_sc &lt;- st_read(&quot;base/rj_setores_censitarios/33SEE250GC_SIR.shp&quot;, options = &quot;ENCODING=WINDOWS-1252&quot;) |&gt; filter(CD_GEOCODM == &quot;3304557&quot;) # Exporta o objeto espacial em rds saveRDS(rj_sc, &quot;base/mapa_setores_rj.rds&quot;) 5.4 Informações da sessão Por fim, abaixo apresentamos as informações da sessão onde os dados foram compilados pela última vez, para que os usuários possam verificar se algum erro decorre de diferentes versões de pacotes. sessionInfo() # R version 4.2.2 (2022-10-31) # Platform: aarch64-apple-darwin20 (64-bit) # Running under: macOS 14.1.1 # # locale: # [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 # # attached base packages: # [1] stats graphics grDevices utils datasets methods base # # other attached packages: # [1] readr_2.1.4 geobr_1.7.0 sf_1.0-13 electionsBR_0.3.3 janitor_2.2.0 dplyr_1.1.2 here_1.0.1 # # loaded via a namespace (and not attached): # [1] Rcpp_1.0.10 pillar_1.9.0 compiler_4.2.2 class_7.3-20 tools_4.2.2 bit_4.0.5 # [7] lubridate_1.9.2 lifecycle_1.0.3 tibble_3.2.1 timechange_0.2.0 pkgconfig_2.0.3 rlang_1.1.1 # [13] DBI_1.1.3 cli_3.6.1 rstudioapi_0.14 parallel_4.2.2 curl_5.0.0 e1071_1.7-13 # [19] withr_2.5.0 stringr_1.5.0 httr_1.4.5 hms_1.1.3 generics_0.1.3 vctrs_0.6.2 # [25] bit64_4.0.5 classInt_0.4-9 rprojroot_2.0.3 grid_4.2.2 tidyselect_1.2.0 snakecase_0.11.0 # [31] glue_1.6.2 data.table_1.14.8 R6_2.5.1 fansi_1.0.4 vroom_1.6.3 tzdb_0.3.0 # [37] magrittr_2.0.3 units_0.8-2 utf8_1.2.3 KernSmooth_2.23-20 stringi_1.7.12 proxy_0.4-27 # [43] crayon_1.5.2 "]]
