[["index.html", "Mapas Eleitorais com R Parte 1 Sobre o Workshop 1.1 Pré-Requisitos 1.2 Autores", " Mapas Eleitorais com R Lucas Gelape, João V. Guedes-Neto e Marco Antonio Faganello Parte 1 Sobre o Workshop Em 2018, PT e PSL protagonizaram a disputa pela presidência. No Capão Redondo, a disputa para deputado reproduziu essa tendência. Porém, em Pinheiros, os mais votados saíram desse padrão: foram PSOL e Novo. Mapas eleitorais permitem investigar esse fenômeno. O objetivo desse workshop é ensinar os participantes a trabalhar com dados espaciais no R a partir de informações eleitorais. Nele, vamos apresentar algumas características e cuidados especiais com esse tipo de dados, como associar os resultados eleitorais ao espaço (inclusive intramunicipais), e a produzir mapas. 1.1 Pré-Requisitos R, RStudio, pacotes (tidyverse e sf) 1.2 Autores Lucas Gelape é pesquisador de pós-doutorado no CEPESP FGV, doutor em Ciência Política pela Universidade de São Paulo. Atualmente, pesquisa temas relacionados a política local e geografia eleitoral. No jornalismo, trabalhou no G1 e no Volt Data Lab/Núcleo. João V. Guedes-Neto é pesquisador de pós-doutorado no CEPESP FGV, doutor em Ciência Política pela Universidade de Pittsburgh. Marco Antonio Faganello é Pesquisador, cientista de dados e pós-doutorando no CEPESP FGV, doutor em Ciência Política pela Universidade Estadual de Campinas (UNICAMP). Atualmente, pesquisa temas relacionados à eleições, partidos, direita e geografia eleitoral. "],["meu-primeiro-mapa.html", "Parte 2 Meu Primeiro Mapa 2.1 A Eleição Presidencial de 2014 2.2 A Eleição Presidencial de 2022", " Parte 2 Meu Primeiro Mapa 2.1 A Eleição Presidencial de 2014 Em 2014, a então presidente Dilma Rousseff (PT) enfrentou o tucano Aécio Neves no segundo turno da eleição presidencial. Para visualizar o resultado desta disputa, elaboraremos um “mapa fácil” que colore os estados brasileiros de acordo com seu candidato mais votado. Para tal, utilizaremos apenas quatro pacotes. O primeiro deles, dplyr, nos ajuda a preparar a tabela com os dados eleitorais e realizar manipulações a fim de prepará-lo para nossas análises. Com função semelhante, o sf nos auxiliar a manipular dados espaciais–essencial para a maior parte das análise que utilizam mapas. O ggplot2, pacote frequentemente utilizado para visualização de dados, nos ajudará a “plotar” as informações nos mapas. Por fim, o pacote geobr foi desenvolvido para gerar “shape files” (arquivos com dados espaciais), os quais utilizaremos como parâmetros para nossos mapas. ## Carregando os pacotes relevantes library(dplyr) ## Gramática para manipulação de dados library(sf) ## Gramática para dados espaciais library(ggplot2) ## Elaboração de gráficos library(geobr) ## Mapas brasileiros Nosso próximo passo é gerar uma tabela (tibble) com os dados que queremos plotar no mapa. Ou seja, uma coluna para os estados brasileiros e outra indicando o candidato vencedor. É importante notar que o nome da variável “estados” (a primeira linha da coluna) precisa estar alinhada com a nomenclatura utilizada no pacote geobr. Por tal motivo, utilizaremos o termo abbrev_state (referindo-se a abreviação dos nomes dos estados). No bloco abaixo, apresentamos uma forma simples para gerar esta tabela. No entanto, também é possível produzí-la no MS Excel (ou seu software de preferência) e importá-la para o R. ganhadores_2014 &lt;- tibble(abbrev_state = c(&quot;RS&quot;, &quot;SC&quot;, &quot;PR&quot;, &quot;SP&quot;, &quot;MG&quot;, &quot;RJ&quot;, &quot;ES&quot;, &quot;MS&quot;, &quot;MT&quot;, &quot;GO&quot;, &quot;DF&quot;, &quot;TO&quot;, &quot;RO&quot;, &quot;AC&quot;, &quot;AM&quot;, &quot;PA&quot;, &quot;AP&quot;, &quot;RR&quot;, &quot;MA&quot;, &quot;PI&quot;, &quot;CE&quot;, &quot;RN&quot;, &quot;PB&quot;, &quot;PE&quot;, &quot;AL&quot;, &quot;SE&quot;, &quot;BA&quot;), ganhador = c(&quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;,&quot;Aécio&quot;, &quot;Dilma&quot;, &quot;Aécio&quot;, &quot;Aécio&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Aécio&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;, &quot;Dilma&quot;)) A tabela (tibble) construída será como esta que apresentamos abaixo. data.frame(ganhadores_2014) ## abbrev_state ganhador ## 1 RS Aécio ## 2 SC Aécio ## 3 PR Aécio ## 4 SP Aécio ## 5 MG Dilma ## 6 RJ Dilma ## 7 ES Aécio ## 8 MS Aécio ## 9 MT Aécio ## 10 GO Aécio ## 11 DF Aécio ## 12 TO Dilma ## 13 RO Aécio ## 14 AC Aécio ## 15 AM Dilma ## 16 PA Dilma ## 17 AP Dilma ## 18 RR Aécio ## 19 MA Dilma ## 20 PI Dilma ## 21 CE Dilma ## 22 RN Dilma ## 23 PB Dilma ## 24 PE Dilma ## 25 AL Dilma ## 26 SE Dilma ## 27 BA Dilma Nosso próximo passo é baixar os dados cartográficos do pacote geobr. Basicamente, queremos baixar uma tabela que contenha os estados brasileiros e informações geográficas (e geométricas!) nos informando como eles devem ser “desenhados”. mapa_brasil &lt;- read_state(code_state=&quot;all&quot;, year=2018, showProgress = FALSE) Agora temos dois tibbles complementares. O ganhadores_2014 inclui qual candidato ganhou o segundo turno da eleição presidencial de 2014 em cada estado brasileiro. O mapa_brasil contém informação cartográfica sobre cada um dos estados brasileiros. Como os estados são identificados a partir da coluna abbrev_state em ambos os bancos de dados, agora podemos utilizar o comando left_join para integrá-los. ganhadores_2014 &lt;- left_join(mapa_brasil, ganhadores_2014, by = &quot;abbrev_state&quot;) Isto gera uma tabela na qual estão presentes os estados, seu devidos ganhadores e os dados cartográficos. A partir destas informações, podemos usar o comando ggplot para elaborar o mapa brasileiro colorido com base nos ganhadores. Note que utilizamos a função mais básica possível a fim de gerar este mapa. Ao longo deste workshop, aprenderemos como mudar sua aparência. ganhadores_2014 %&gt;% ggplot() + ## Gera o gráfico geom_sf(aes_string(fill = &quot;ganhador&quot;)) ## Identifica a coluna &quot;ganhador&quot; como fonte para colorir os estados 2.2 A Eleição Presidencial de 2022 Os mapas nos ajudam a contar uma história. Agora que geramos o mapa eleitoral da eleição presidencial de 2014, faremos o mesmo procedimento para compará-lo com o que ocorreu em 2022 quando Jair Bolsonaro (PL) foi derrotado pelo petista Lula da Silva. Mais uma vez, nosso trabalho começa a partir da criação de um tibble com os vencedores do segundo turno em cada estado brasileiro. Lembre-se que os estados devem ser identificados como abbrev_state. ganhadores_2022 &lt;- tibble(abbrev_state = c(&quot;RS&quot;, &quot;SC&quot;, &quot;PR&quot;, &quot;SP&quot;, &quot;MG&quot;, &quot;RJ&quot;, &quot;ES&quot;, &quot;MS&quot;, &quot;MT&quot;, &quot;GO&quot;, &quot;DF&quot;, &quot;TO&quot;, &quot;RO&quot;, &quot;AC&quot;, &quot;AM&quot;, &quot;PA&quot;, &quot;AP&quot;, &quot;RR&quot;, &quot;MA&quot;, &quot;PI&quot;, &quot;CE&quot;, &quot;RN&quot;, &quot;PB&quot;, &quot;PE&quot;, &quot;AL&quot;, &quot;SE&quot;, &quot;BA&quot;), ganhador = c(&quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Lula&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;,&quot;Bolsonaro&quot;, &quot;Lula&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Bolsonaro&quot;, &quot;Bolsonaro&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;, &quot;Lula&quot;)) Como já haviámos baixado o dados cartográficos, não é necessário repetir o processo. Podemos ir diretamente para a etapa de integrá-los ao banco de dados eleitoral de 2022. ganhadores_2022 &lt;- left_join(mapa_brasil, ganhadores_2022, by = &quot;abbrev_state&quot;) Por fim, utilizamos o mesmo código da etapa anterior para gerar o mapa de 2022. ganhadores_2022 %&gt;% ggplot() + ## Gera o gráfico geom_sf(aes_string(fill = &quot;ganhador&quot;)) ## Identifica a coluna &quot;ganhador&quot; como fonte para colorir os estados Pronto! Temos nossa primeira história a ser contada. Ainda que existam diferenças, os mapas são muito parecidos. Ou seja, a distribuição geográfica da campanha vitoriosa de Dilma Rousseff em 2014 é muito parecida com aquela realizada por Lula da Silva em 2022. Os mapas demonstram isto claramente! Agora, se tiver tempo, sugerimos que você faça os mapas para outras eleições presidenciais. Por exemplo, o que aconteceu em 1994 e 2002? "],["mapas-municipais.html", "Parte 3 Mapas municipais 3.1 Organização Intramunicipal 3.2 Importação das Bases 3.3 Preparação do Banco de Dados 3.4 Mapa Coroplético", " Parte 3 Mapas municipais 3.1 Organização Intramunicipal Administrativamente, a Justiça Eleitoral se organiza em zonas eleitorais, nas quais estão localizados os locais de votação, que abrigam as seções eleitorais (sendo que cada seção eleitoral corresponde a uma urna). Dentro dos municípios, porém, a organização territorial da Justiça Eleitoral não coincide necessariamente com outras divisões administrativas. Ou seja, os limites das zonas eleitorais muitas vezes não correspondem aos limites de bairros ou distritos. Além disso, os Tribunais Regionais Eleitorais (TREs) não têm o costume de divulgar arquivos espaciais que apresentem os limites dessas zonas. Então, como produzir mapas de resultados eleitorais dentro de municípios? Para isso, utilizamos outra fonte de dados do Tribunal Superior Eleitoral (TSE). O TSE divulga os endereços de todos os locais de votação brasileiros e as suas seções eleitorais correspondentes de todas as disputas desde 2008 (alguns TREs divulgam essas informações para eleições prévias a 2008) e podem ser usadas para esse fim. Esses registros administrativos têm, inclusive, uma coluna com a informação de bairro desse endereço. Bastaria então unir o banco de resultados por seção eleitoral com esse de locais de votação, somar os votos no bairro informado pela coluna dos registros do TSE, acoplar os resultados num mapa e voilà, certo? Infelizmente, não. A informação do bairro advinda dos registros do TSE frequentemente não coincide com o bairro onde geograficamente está esse local de votação (para mais informações, veja Gelape, 2017, 2018). Assim, para produzirmos mapas com votações de candidatos dentro de um município, precisamos encontrar a localização dos locais de votação no espaço. Neste exercício, utilizamos um banco de dados disponibilizado pelo prof. Daniel Hidalgo (do Massachusetts Institute of Technology, MIT) que cataloga a latitude e longitude para todos os locais de votação brasileiros entre 2006 e 2020. Esse foi um esforço de pesquisa que cruzou diferentes fontes de dados para determinar as coordenadas geográficas e que contou com a participação do FGV-CEPESP (para mais informações, deem uma olhada no repositório do GitHub – e na documentação da metodologia deste processo). Com a latitude e longitude, podemos cruzar essa informação espacial com outra(s) informações espaciais, como um mapa de bairros de um município, para passar aos nossos pontos (isto é, os locais de votação) tais informações. 3.2 Importação das Bases Neste exercício, prepararemos um mapa da cidade de São Paulo contendo os dados de votação por seção eleitoral do candidato a prefeito Guilherme Boulos (PSOL) em 2020. Nosso primeiro passo, como no exercício anterior, será carregar os pacotes relevantes para a nossa análise. O pacote tidyverse inclui ferramentas importantes já utilizadas anteriormente, como o ggplot2 e o dplyr. Também carregamos novamente os pacotes sf e geobr. Temos, no entanto, três novidades. Primeiro, o ggspatial nos ajudar a plotar mapas mais detalhados (de certa maneira, ele é utilizado em conjunto com o ggplot2). O classInt nos ajuda a preparar mapas, por exemplo, a partir de métodos de seleção de intervalos. Por fim, o pacote cartography melhora a apresentação dos mapas a partir de elementos mais sofisticados, como a inclusão da rosa dos ventos, legendas etc. library(tidyverse) library(sf) library(geobr) library(ggspatial) library(classInt) library(cartography) Agora que já temos os pacotes carregados, vamos baixar os bancos de dados (todos preparados em formato RDS). Em primeiro lugar, baixamos a base de dados contendo dados de votacao por secao eleitoral do candidato a prefeito Guilherme Boulos (PSOL), e dos candidatos a vereador Milton Leite (DEM), Fernando Holiday (PATRIOTA) e Eduardo Suplicy (PT). Ela está salva como base2020.rds. Para facilitar nossa análise, aproveitamos o mesmo bloco de código para encurtar os nomes de cada um destes candidatos. Para tal, utilizamos as funções mutate e case_when do pacote dplyr. candsp2020 &lt;- readRDS(&quot;base/base2020.rds&quot;) |&gt; mutate(nm_votavel = case_when( nm_votavel == &quot;MILTON LEITE DA SILVA&quot; ~ &quot;Milton Leite&quot;, nm_votavel == &quot;GUILHERME CASTRO BOULOS&quot; ~ &quot;Boulos&quot;, nm_votavel == &quot;EDUARDO MATARAZZO SUPLICY&quot; ~ &quot;Suplicy&quot;, nm_votavel == &quot;FERNANDO HOLIDAY SILVA BISPO&quot; ~ &quot;Holiday&quot;)) Para se ter ideia de seu conteúdo, apresentamos sua head abaixo. São 28 colunas (variáveis) e 80.984 linhas (observações) contendo o número de votos que cada um dos três candidatos obteve na eleição de 2020, sendo Boulos para prefeito e os demais para vereador. head(candsp2020) ## # A tibble: 6 × 28 ## dt_geracao hh_geracao ano_eleicao cd_tipo_eleicao nm_tipo_eleicao nr_turno cd_eleicao ds_eleicao dt_eleicao tp_abrangencia sg_uf sg_ue nm_ue ## &lt;chr&gt; &lt;time&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 21/12/2020 16:55:14 2020 2 Eleição Ordinária 1 426 Eleições Municip… 15/11/2020 M SP 71072 SÃO … ## 2 21/12/2020 16:55:14 2020 2 Eleição Ordinária 1 426 Eleições Municip… 15/11/2020 M SP 71072 SÃO … ## 3 21/12/2020 16:55:14 2020 2 Eleição Ordinária 1 426 Eleições Municip… 15/11/2020 M SP 71072 SÃO … ## 4 21/12/2020 16:55:14 2020 2 Eleição Ordinária 1 426 Eleições Municip… 15/11/2020 M SP 71072 SÃO … ## 5 21/12/2020 16:55:14 2020 2 Eleição Ordinária 1 426 Eleições Municip… 15/11/2020 M SP 71072 SÃO … ## 6 21/12/2020 16:55:14 2020 2 Eleição Ordinária 1 426 Eleições Municip… 15/11/2020 M SP 71072 SÃO … ## # ℹ 15 more variables: cd_municipio &lt;dbl&gt;, nm_municipio &lt;chr&gt;, nr_zona &lt;dbl&gt;, nr_secao &lt;dbl&gt;, cd_cargo &lt;dbl&gt;, ds_cargo &lt;chr&gt;, nr_votavel &lt;dbl&gt;, ## # nm_votavel &lt;chr&gt;, qt_votos &lt;dbl&gt;, nr_local_votacao &lt;dbl&gt;, sq_candidato &lt;dbl&gt;, nm_local_votacao &lt;chr&gt;, ds_local_votacao_endereco &lt;chr&gt;, ## # voto_total_secao &lt;dbl&gt;, voto_val_total_secao &lt;dbl&gt; Nosso próximo passo é carregar a base com dados geolocalizados de cada um dos locais de votação no município de São Paulo. Seu nome é baselocais2020SP.rds. lvsp2020 &lt;- readRDS(&quot;base/baseLocais2020SP.rds&quot;) Ao abrir esta base de dados, você verá o endereço de cada local de votação (por ex., o Colégio Objetivo na Av. Paulista, 900, Bela Vista), acompanhado de sua longitude e latitude, além de outros dados espaciais. A base possui 2.063 observações e 19 variáveis. head(lvsp2020) ## # A tibble: 6 × 19 ## local_id ano sg_uf cd_localidade_tse cod_localidade_ibge nr_zona nr_locvot nr_cep nm_localidade nm_locvot ds_endereco ds_bairro pred_long pred_lat ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 678500 2020 SP 71072 3550308 1 1015 1310100 SÃO PAULO COLÉGIO … AV. PAULIS… BELA VIS… -46.7 -23.6 ## 2 670114 2020 SP 71072 3550308 2 1015 5001000 SÃO PAULO COLÉGIO … AV. FRANCI… AGUA BRA… -46.7 -23.5 ## 3 688691 2020 SP 71072 3550308 4 1015 3103000 SÃO PAULO EE. PROF… RUA DA MOÓ… MOOCA -46.6 -23.6 ## 4 694622 2020 SP 71072 3550308 5 1015 1427001 SÃO PAULO CLUBE AT… RUA ESTADO… JARDIM A… -46.7 -23.6 ## 5 696661 2020 SP 71072 3550308 6 1015 4117020 SÃO PAULO EE. MARE… RUA DONA J… VILA MAR… -46.6 -23.6 ## 6 674162 2020 SP 71072 3550308 246 1015 4754010 SÃO PAULO EE. PROF… AVENIDA MÁ… SANTO AM… -46.7 -23.7 ## # ℹ 5 more variables: pred_dist &lt;dbl&gt;, tse_lat &lt;dbl&gt;, tse_long &lt;dbl&gt;, long &lt;dbl&gt;, lat &lt;dbl&gt; Nosso próximo passo será conventer os dados de longitude (long) e latitude (lat) utilizando o pacote sf em um objeto de featires espaciais. Isto é importante para compatibilizar a estrutura dos dados com os pacotes e mapas com os quais estamos trabalhando. Mais especificamente, a transformação tem por objetivo utilizar o sistema de referência de coordenadas (CRS) SIRGAS 2000. Este passo é padrão para a elaboração da maioria dos mapas brasileiros. lvsp2020 &lt;- lvsp2020 |&gt; # Convertendo o dataframe &#39;lvsp2020&#39; em um objeto de features espaciais (&#39;sf&#39;) st_as_sf( coords = c(&quot;long&quot;, &quot;lat&quot;), # Definindo as colunas &#39;long&#39; e &#39;lat&#39; como coordenadas crs = 4674 # Definindo o sistema de referência de coordenadas (CRS) como 4674 - SIRGAS 2000 ) Pronto! Já temos os locais de votação e quantos votos os candidatos obtiveram em cada um deles. Temos, no entanto, um desafio. Havíamos falado que a Justiça Eleitoral se abriga por zonas eleitorais mas os limites destas zonas geralmente não são divulgados pelos TREs. O que nós faremos, então, é utilizar outra delimitação espacial como “aproximação” para apresentar a distribuição dos votos no município de São Paulo. Uma estratégia comum é separar os locais de votação por distrito (o equivalente a bairro no município de São Paulo). Na base de dados mapas_distritos_sp.rds temos os mapas dos 96 distritos deste município. Por isso, iremos carregá-la agora. mapa &lt;- readRDS(&quot;base/mapa_distritos_sp.rds&quot;) Esta base se parece com aquelas que chamamos de mapa_brasil na parte anterior deste workshop. Para cada um dos distritos (coluna name_district), ela possui uma coluna chamada geom com a informação do polígono que representa o território do distrito. Veja abaixo como fica um mapa simples no qual utilizamos estes polígonos para plotar os distritos na cidade de São Paulo. # pre-visualização do mapa com shape dos distritos da cidade de Sao Paulo # usand ggplot2 ggplot(mapa) + # Adicionando camadas de features espaciais ao gráfico geom_sf() Agora, vamos verificar onde fica cada um dos locais de votação do município de São Paulo. No código abaixo, utilizamos os ggplot para plotar o mapa com os distritos. Depois, com o comando geom_sf(data = lvsp2020), pedimos ao ggplot para inserir a localização dos locais de votação (base lvsp2020) no mesmo mapa. Por fim, o theme_void ajusta o layout do gráfico para facilitar a visualização. ggplot(mapa) + # Gera gráfico utilizando a base mapa geom_sf() + # Transforma em gráfico geoespacial geom_sf(data = lvsp2020) + # Adiciona camada com pontos dos locais de votação theme_void() # Ajusta o layout do gráfico deixando a tela de fundo em branco 3.3 Preparação do Banco de Dados No último exercício, preparamos o mapa da cidade de São Paulo dividido por seus distritos e, ao fim, localizamos nele cada um dos locais de votação da cidade. Nosso próximo passo será preparar os dados eleitorais para que possamos integrar as bases e, ao fim, gerar o mapa com a distribuição de votos do candidato selecionao (inicialmente, o psolista Guilherme Boulos). O primeiro passo será gerar uma base candsp2020_porlv na qual inserimos apenas o candidato Boulos e somamos a quantidade de votos obtidas em todas as urnas de cada local de votação. Note que você pode realizar o mesmo procedimento para outros candidatos. Para tal, basta substituir “Boulos” pelo nome do seu candidato de escolha. Lembre-se que as possibilidades são Milton Leite, Suplicy e Holiday. # Calcula votos por local de votacao candsp2020_porlv &lt;- candsp2020 |&gt; # Filtra somente pelo Boulos filter(nm_votavel == &quot;Boulos&quot;) |&gt; # Soma os votos do candidato e total da urna por local de votacao group_by(nr_zona, nr_local_votacao, nm_votavel) |&gt; summarise(votos_cand = sum(qt_votos), votos_validos = sum(voto_val_total_secao)) |&gt; ungroup() |&gt; # Calcula o percencual de votos por local mutate(votos_cand_porc = round(votos_cand/votos_validos*100,1)) No exercício do mapa do Brasil, utilizamos o comando left_join para integrar a base de dados com os ganhadores em cada estado com a base que possuia os polígonos de cada estado (a coluna geom). Agora faremos algo muito parecido. Integraremos a base que acabamos de criar (candsp2020_porlv) a base que possui os locais de votação (lvsp2020). Para tal, também renomeamos o nr_local_votacao para nr_locvot a fim de assegurar que esta coluna tem o mesmo nome em ambas as bases. Por fim, transformamos as informações em objeto espacial com a função st_as_sf. # Une com a base de LV geolocalizado candsp2020_porlv &lt;- candsp2020_porlv |&gt; # Renomeia a variavel nr_local_votacao para facilitar o join rename(nr_locvot = nr_local_votacao) |&gt; # Traz a informacao da base de LV geolocalizado left_join(lvsp2020, by = c(&quot;nr_zona&quot;, &quot;nr_locvot&quot;)) |&gt; # Transforma em objeto espacial st_as_sf(sf_column_name = &quot;geometry&quot;) Pronto! Agora vamos gerar nosso primeiro mapa para pré-visualizar o que fizemos até aqui. A função é muito parecida com as que já utilizamos nos exercícios anteriores. O ggplot carrega o gráfico, o primeiro geom_sf informa a base com os polígonos e, na linha seguinte, informa que a coluna votos_cand_porc deve ser utilizada para estimar o tamanho (size) do pontos (quanto mais votos, maiores serão) e a cor (color) dos pontos (quanto mais votos, mais claro é a tonalidade do azul). # Pré-visualização dos votos dos candidatos por local de votação candsp2020_porlv |&gt; filter(nm_votavel == &quot;Boulos&quot;) |&gt; ggplot() + geom_sf(data=mapa)+ geom_sf(aes(size=votos_cand_porc, color=votos_cand_porc))+ theme_void() Note que neste mapa, os locais de votação estão em sua localização original. Ainda não geramos uma base na qual eles são inseridos dentro dos distritos. Para tal, utilizaremos o comando st_join (spacial join) para integrar a base de locais de votação (lvsp2020) ao mapa. *** Obter o bairro do local de votacao # Faz o spatial join lvsp2020_distrito &lt;- st_join(lvsp2020, mapa) Existe, no entanto, um cuidado. Lembre-se que estamos fazendo uma reposição “artificial”. Isto é, os locais de votação não foram feitos para se enquadrarem perfeitamente nos distritos de São Paulo. O TRE tem sua própria distribuição espacial que não necessariamente bate com aquela do IBGE. Utilizando o comando nrow, verificamos que a base lvsp2020_distrito tem uma linha a mais que a base lvsp2020! Ou seja, 2.064 linhas comparado com 2.063. nrow(lvsp2020) ## [1] 2063 nrow(lvsp2020_distrito) # Ele tem uma linha a mais! ## [1] 2064 O gráfico que geramos abaixo nos auxilia na identificação do problema. Existe um local de votação que está localizado exatamente na divisa entre Vila Mariana e Bela Vista. Por isso, os nosso trabalho de integrar bases de dados acabou gerando o mesmo local de votação duas vezes–uma para cada bairro. # Isso ocorreu porque um LV está bem na divisa entre dois distritos ggplot() + geom_sf(data=mapa %&gt;% filter(name_district %in% c(&quot;Vila Mariana&quot;, &quot;Bela Vista&quot;)))+ geom_sf(data = lvsp2020 |&gt; slice(269), size=2)+ theme_void() Existem várias soluções possíveis para este problema. Perceba que não necessariamente existirá a solução perfeita para todos os casos. É necessário refletir sobre o objetivo da análise. Primeiro, poderíamos escolher aleatoriamente onde colocar este local de votação (Vila Mariana ou Bela Vista). Copiamos abaixo o bloco de código que permitirá realizar esta modificação. # Possivel solução: selecionar aleatoriamente o bairro ao qual ele esta atribuido #lvsp2020_distrito &lt;- lvsp2020_distrito |&gt; # group_by(nr_locvot, nr_zona) |&gt; # slice_sample(n = 1) |&gt; # ungroup() |&gt; # # Seleciona so as variaveis que vamos usar para o mapa # select(nr_zona, nr_locvot, name_district) |&gt; # # Retira a geometria, para ela ser tratada como uma tabela # st_drop_geometry() #nrow(lvsp2020_distrito) # 2.063 linhas, pronto! Para este exercício, selecionamos uma outra solução. Decidimos criar um comando geral que faz com que sempre que existirem dois pontos, o primeiro deles será escolhido. # solução: escolher o primeiro bairro que aparece ponto_shape &lt;- st_intersects(lvsp2020, mapa, sparse = T) ponto_shape &lt;- unlist(map(ponto_shape, ~.[1])) # faz com que quando exista dois pontos o primeiro seja escolhido ponto_shape &lt;- mapa$name_district[ponto_shape] ponto_shape[269] ## [1] &quot;Bela Vista&quot; lvsp2020$bairro &lt;- ponto_shape Da mesma forma que criamos uma base com votos por local de votação (candsp2020_porlv), agora criamos uma base que apresenta os votos por distrito (candsp2020_pordist). Lembre-se que isto foi possível porque compatibilizamos ambas as localizações geográficas. # agregação dos votos nos locais de votação por distrito candsp2020_pordist &lt;- candsp2020_porlv |&gt; # Retira a informacao da geometria do ponto st_drop_geometry() |&gt; # Traz a informacao do distrito referente ao ponto, que obtivemos acima left_join(lvsp2020_distrito, by = c(&quot;nr_zona&quot;, &quot;nr_locvot&quot;)) Para melhorar a visualização dos dados, calculamos na coluna votos_cand_porc a porcentagem dos votos que o candidato Boulos recebeu em cada distrito. # Soma os votos do candidato por distrito e calcula o % candsp2020_pordist &lt;- candsp2020_pordist |&gt; group_by(name_district, nm_votavel) |&gt; summarise(votos_cand = sum(votos_cand), votos_validos = sum(votos_validos)) |&gt; ungroup() |&gt; mutate(votos_cand_porc = round(votos_cand/votos_validos*100,1)) Por fim, geramos um objeto espacial integrando com o comando left_join a base geoespacial mapa à base eleitoral candsp2020_pordist com base na coluna name_district que define o nome dos distritos. Ou seja, queremos saber as informações espaciais para cada um dos distritos agora que já sabemos a proporção de votos que o Boulo obteve em cada um deles. # Cria um objeto espacial em que passamos para o mapa a votacao # de Boulos em cada um dos distritos de SP boulos_final &lt;- left_join(mapa, candsp2020_pordist, by = c(&quot;name_district&quot;)) Pronto! Agora já podemos pré-visualizar o mapa de votação do Boulos por distrito de São Paulo! Mais uma vez, utilizamos o comando ggplot para gerar o gráfico e, dentro do comando geom_sf, utilizamos a função fill para preencher cada distrito com tonalidades diferentes de acordo com a porcentagem de votos obtida pelo candidato selecionado (votos_cand_porc). # pré-visualização dos votos dos candidatos por distrito boulos_final |&gt; ggplot() + geom_sf(aes(fill=votos_cand_porc))+ theme_void() 3.4 Mapa Coroplético Existem diversas escalas para definir os cortes de uma variavel, que vao informar como colorir areas de um mapa. Para mais informacoes, veja este vídeo no YouTube. Ele está em inglês, mas é possível gerar legendas traduzidas automaticamente. Vejam como ao escolher duas delas, produzimos dois mapas que sugerem informacoes diferentes fundamentados na mesma base de dados. Testaremos abaixo a abordagem de Cortes de Jenks (jenks) e Intervalos Geogmétricos (geom). O corte de jenks é feito com o pacote classIntervals que carregamos para nosso primeiro exercício. Note que ao fim do comando, identificamos o tipo de corte. # Cria os cortes e os guardamos em um objeto cortes &lt;- classIntervals(boulos_final$votos_cand_porc, 4, &quot;jenks&quot;) # Cria uma variável com os cortes boulos_final$cortes_jenks &lt;- cut(boulos_final$votos_cand_porc, cortes$brks, include.lowest = T) Agora realizamos um procedimento muito parecido para gerar os intervalos geométricos. Para tal, substituímos jenks por geom. # Cria os cortes e os guardamos em um objeto cortes &lt;- getBreaks(boulos_final$votos_cand_porc, 4, &quot;geom&quot;) # Insere os cortes na base de dados usando a função cut boulos_final$int_geom &lt;- cut(boulos_final$votos_cand_porc, cortes, include.lowest = T) Agora, faremos a visualização de ambos os cortes. Começamos pelo jenks. # Visualização do corte jenks ggplot() + geom_sf(data=boulos_final, aes(fill=cortes_jenks))+ scale_fill_brewer(palette = &quot;RdBu&quot;, name=&quot;Votação (%)&quot;)+ theme_void() O código apresentado logo abaixo gera o mesmo mapa utilizando os cortes geom. Note na legenda que os cortes são consideravelmente diferentes. Isto leva a apresentação de gráficos com cores igualmente diferentes. Compare as diferentes regiões da cidade. É visível que, dependendo do corte, o mapa pode acabar contando uma história diferente. Por tanto, é importante refletir antes de decidir qual corte será utilizado. Mais uma vez, não existe solução perfeita. # Visualização do corte geom ggplot() + geom_sf(data=boulos_final, aes(fill=int_geom))+ scale_fill_brewer(palette = &quot;RdBu&quot;, name=&quot;Votação (%)&quot;)+ theme_void() Em boa parte dos casos, porém, você vai querer criar uma escala a partir dos resultados observados. Por exemplo, em vez do corte elaborado pela metodologia geom que gerou uma categoria variando entre 11,6% e 14,9%, talvez você queira um corte indo de 10,0% até 15,0%. No código abaixo, criamos uma escala manualmente com intervalos de 5 p.p. em 5 p.p., inciando em 10. Além disso, incluimos diversos elementos, como titulo, legenda, escala, e rosa dos ventos. Você poderá ver como modificar cada um destes elementos a partir dos comentários que inserimos no bloco de código. Como você perceberá, o resultado final parece muito mais profissional (e agradável aos olhos) que os mapas gerados nos exercícios anteriores. # A partir do objeto espacial boulos_final |&gt; # Cria uma variável categórica e preenche os níveis que serão a legenda mutate( categoria = case_when( is.na(votos_cand_porc) ~ &quot;Sem LV&quot;, votos_cand_porc &gt; 10 &amp; votos_cand_porc &lt;= 15 ~ &quot;10-15%&quot;, votos_cand_porc &gt; 15 &amp; votos_cand_porc &lt;= 20 ~ &quot;15-20%&quot;, votos_cand_porc &gt; 20 &amp; votos_cand_porc &lt;= 25 ~ &quot;20-25%&quot;, votos_cand_porc &gt; 25 &amp; votos_cand_porc &lt;= 30 ~ &quot;25-30%&quot;, votos_cand_porc &gt; 30 ~ &quot;&gt;30%&quot;), categoria = factor( categoria, levels = c(&quot;Sem LV&quot;, &quot;10-15%&quot;, &quot;15-20%&quot;, &quot;20-25%&quot;, &quot;25-30%&quot;, &quot;&gt;30%&quot;))) |&gt; # Inicia o ggplot ggplot() + # Usa uma camada de sf geom_sf(aes(fill = categoria), color = &quot;black&quot;, size = 0.1) + # Retira o datum coord_sf(datum = NA) + # Coloca o fill na paleta de verdes scale_fill_brewer(palette = &quot;YlOrBr&quot;) + # Adicionar título, subtítulo e legenda labs( title = &quot;Votação de Guilherme Boulos (2020, 1º turno)&quot;, subtitle = &quot;Distritos do município do SP&quot;, caption = &quot;Fonte: Elaborado por Gelape, Guedes e Faganello (2023), a partir de\\ndados de Daniel Hidalgo, TSE, IBGE.&quot;) + # Adiciona escala ggspatial::annotation_scale( location = &quot;br&quot;, width_hint = 0.4, line_width = 0.5, height = unit(0.1,&quot;cm&quot;)) + # Coloca título na legenda guides(fill = guide_legend(title = &quot;Votos válidos (%)&quot;)) + # Ajusta elementos do tema do ggplot theme( # Posição e direção da legenda legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;, # Centralização de alguns elementos textuais plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5), plot.caption = element_text(hjust = 0.5)) + # Adiciona rosa-dos-ventos ggspatial::annotation_north_arrow( location = &quot;br&quot;, which_north = &quot;true&quot;, style = north_arrow_fancy_orienteering(), # Ajusta a altura da rosa-dos-ventos (pode exigir tentativa e erro) pad_x = unit(0.5, &quot;cm&quot;), pad_y = unit(1, &quot;cm&quot;)) "],["exercício-final.html", "Parte 4 Exercício Final", " Parte 4 Exercício Final Texto texto texto. "],["extra.html", "Parte 5 Extra", " Parte 5 Extra Texto texto texto. "],["references.html", "References", " References "]]
