# Mapas municipais

## Organização Intramunicipal

Administrativamente, a Justiça Eleitoral se organiza em zonas eleitorais, nas quais estão localizados os locais de votação, que abrigam as seções eleitorais (sendo que cada seção eleitoral corresponde a uma urna). Dentro dos municípios, porém, a organização territorial da Justiça Eleitoral não coincide necessariamente com outras divisões administrativas. Ou seja, os limites das zonas eleitorais muitas vezes não correspondem aos limites de bairros ou distritos.

Além disso, os Tribunais Regionais Eleitorais (TREs) não têm o costume de divulgar arquivos espaciais que apresentem os limites dessas zonas. Então, como produzir mapas de resultados eleitorais dentro de municípios?

Para isso, utilizamos outra fonte de dados do Tribunal Superior Eleitoral (TSE). O TSE divulga os endereços de todos os locais de votação brasileiros e as suas seções eleitorais correspondentes de todas as disputas desde 2008 (alguns TREs divulgam essas informações para eleições prévias a 2008) e podem ser usadas para esse fim. Esses registros administrativos têm, inclusive, uma coluna com a informação de bairro desse endereço. 

Bastaria então unir o banco de resultados por seção eleitoral com esse de locais de votação, somar os votos no bairro informado pela coluna dos registros do TSE, acoplar os resultados num mapa e voilà, certo? Infelizmente, não. A informação do bairro advinda dos registros do TSE frequentemente não coincide com o bairro onde geograficamente está esse local de votação (para mais informações, veja Gelape, 2017, 2018). 

Assim, para produzirmos mapas com votações de candidatos dentro de um município, precisamos encontrar a localização dos locais de votação no espaço. Neste exercício, utilizamos um banco de dados disponibilizado pelo prof. Daniel Hidalgo (do Massachusetts Institute of Technology, MIT) que cataloga a latitude e longitude para todos os locais de votação brasileiros entre 2006 e 2020. Esse foi um esforço de pesquisa que cruzou diferentes fontes de dados para determinar as coordenadas geográficas e que contou com a participação do FGV-CEPESP (para mais informações, deem uma olhada no <a href="https://github.com/fdhidalgo/geocode_br_polling_stations" target="blank">repositório do GitHub</a> -- e na <a href="https://raw.githack.com/fdhidalgo/geocode_br_polling_stations/master/doc/geocoding_procedure.html" target="blank">documentação da metodologia deste processo</a>). Com a latitude e longitude, podemos cruzar essa informação espacial com outra(s) informações espaciais, como um mapa de bairros de um município, para passar aos nossos pontos (isto é, os locais de votação) tais informações. 

## Importação das Bases

Neste exercício, prepararemos um mapa da cidade de São Paulo contendo os dados de votação por seção eleitoral do candidato a prefeito Guilherme Boulos (PSOL) em 2020.

Nosso primeiro passo, como no exercício anterior, será carregar os pacotes relevantes para a nossa análise. O pacote *tidyverse* inclui ferramentas importantes já utilizadas anteriormente, como o *ggplot2* e o *dplyr*. Também carregamos novamente os pacotes *sf* e *geobr*. Temos, no entanto, três novidades. Primeiro, o *ggspatial* nos ajudar a plotar mapas mais detalhados (de certa maneira, ele é utilizado em conjunto com o *ggplot2*). O *classInt* nos ajuda a preparar mapas, por exemplo, a partir de métodos de seleção de intervalos. Por fim, o pacote *cartography* melhora a apresentação dos mapas a partir de elementos mais sofisticados, como a inclusão da rosa dos ventos, legendas etc.

```{r carregando os pacotes relevantes, message = FALSE}
library(tidyverse)
library(sf)
library(geobr)
library(ggspatial)
library(classInt)
library(cartography)
```

Agora que já temos os pacotes carregados, vamos baixar os bancos de dados (todos preparados em formato *RDS*). Em primeiro lugar, baixamos a base de dados contendo dados de votacao por secao eleitoral do candidato a prefeito Guilherme Boulos (PSOL), e dos candidatos a vereador Milton Leite (DEM), Fernando Holiday (PATRIOTA) e Eduardo Suplicy (PT). Ela está salva como *base2020.rds*.

Para facilitar nossa análise, aproveitamos o mesmo bloco de código para encurtar os nomes de cada um destes candidatos. Para tal, utilizamos as funções *mutate* e *case_when* do pacote *dplyr*.

```{r carrega bd de votação por seção eleitoral, message = FALSE}
candsp2020 <- readRDS("base/base2020.rds") |> 
  mutate(nm_votavel = case_when(
    nm_votavel == "MILTON LEITE DA SILVA" ~ "Milton Leite",
    nm_votavel == "GUILHERME CASTRO BOULOS" ~ "Boulos",
    nm_votavel == "EDUARDO MATARAZZO SUPLICY" ~ "Suplicy",
    nm_votavel == "FERNANDO HOLIDAY SILVA BISPO" ~ "Holiday"))
```

Para se ter ideia de seu conteúdo, apresentamos sua *head* abaixo. São 28 colunas (variáveis) e 80.984 linhas (observações) contendo o número de votos que cada um dos três candidatos obteve na eleição de 2020, sendo Boulos para prefeito e os demais para vereador.

```{r ver bd de votação por seção eleitoral, message = FALSE}
head(candsp2020)
```

Nosso próximo passo é carregar a base com dados geolocalizados de cada um dos locais de votação no município de São Paulo. Seu nome é *baselocais2020SP.rds*.

```{r carrega bd de local por seção eleitoral, message = FALSE}
lvsp2020 <- readRDS("base/baseLocais2020SP.rds")
```

Ao abrir esta base de dados, você verá o endereço de cada local de votação (por ex., o Colégio Objetivo na Av. Paulista, 900, Bela Vista), acompanhado de sua longitude e latitude, além de outros dados espaciais. A base possui 2.063 observações e 19 variáveis.

```{r ver bd de local por seção eleitoral, message = FALSE}
head(lvsp2020)
```

Nosso próximo passo será conventer os dados de longitude (*long*) e latitude (*lat*) utilizando o pacote *sf* em um objeto de *featires espaciais*. Isto é importante para compatibilizar a estrutura dos dados com os pacotes e mapas com os quais estamos trabalhando. Mais especificamente, a transformação tem por objetivo utilizar o sistema de referência de coordenadas (CRS) SIRGAS 2000. Este passo é padrão para a elaboração da maioria dos mapas brasileiros.

```{r compatibilizacao dos mapas, message = FALSE}
lvsp2020 <- 
  lvsp2020 |> 
  # Convertendo o dataframe 'lvsp2020' em um objeto de features espaciais ('sf')
  st_as_sf(
    coords = c("long", "lat"), # Definindo as colunas 'long' e 'lat' como coordenadas
    crs = 4674                  # Definindo o sistema de referência de coordenadas (CRS) como 4674 - SIRGAS 2000
  ) 
```

Pronto! Já temos os locais de votação e quantos votos os candidatos obtiveram em cada um deles. Temos, no entanto, um desafio. Havíamos falado que a Justiça Eleitoral se abriga por zonas eleitorais mas os limites destas zonas geralmente não são divulgados pelos TREs. O que nós faremos, então, é utilizar outra delimitação espacial como "aproximação" para apresentar a distribuição dos votos no município de São Paulo. Uma estratégia comum é separar os locais de votação por distrito (o equivalente a bairro no município de São Paulo). Na base de dados *mapas_distritos_sp.rds* temos os mapas dos 96 distritos deste município. Por isso, iremos carregá-la agora.

```{r carrega bd de mapas dos distritos de São Paulo, message = FALSE}
mapa <- readRDS("base/mapa_distritos_sp.rds")
```

Esta base se parece com aquelas que chamamos de *mapa_brasil* na parte anterior deste workshop. Para cada um dos distritos (coluna *name_district*), ela possui uma coluna chamada *geom* com a informação do polígono que representa o território do distrito. Veja abaixo como fica um mapa simples no qual utilizamos estes polígonos para plotar os distritos na cidade de São Paulo.

```{r mapa-sp, warning = FALSE}
# pre-visualização do mapa com shape dos distritos da cidade de Sao Paulo
# usand ggplot2
ggplot(mapa) +
  # Adicionando camadas de features espaciais ao gráfico
  geom_sf()
```

Agora, vamos verificar onde fica cada um dos locais de votação do município de São Paulo. No código abaixo, utilizamos os *ggplot* para plotar o mapa com os distritos. Depois, com o comando *geom_sf(data = lvsp2020)*, pedimos ao *ggplot* para inserir a localização dos locais de votação (base *lvsp2020*) no mesmo mapa. Por fim, o *theme_void* ajusta o layout do gráfico para facilitar a visualização.

```{r mapa-sp-locais, warning = FALSE}
ggplot(mapa) + # Gera gráfico utilizando a base mapa
  geom_sf() + # Transforma em gráfico geoespacial
  geom_sf(data = lvsp2020) + # Adiciona camada com pontos dos locais de votação
  theme_void() # Ajusta o layout do gráfico deixando a tela de fundo em branco
```

## Preparação do Banco de Dados

No último exercício, preparamos o mapa da cidade de São Paulo dividido por seus distritos e, ao fim, localizamos nele cada um dos locais de votação da cidade. Nosso próximo passo será preparar os dados eleitorais para que possamos integrar as bases e, ao fim, gerar o mapa com a distribuição de votos do candidato selecionao (inicialmente, o psolista Guilherme Boulos).

O primeiro passo será gerar uma base *candsp2020_porlv* na qual inserimos apenas o candidato Boulos e somamos a quantidade de votos obtidas em todas as urnas de cada local de votação. Note que você pode realizar o mesmo procedimento para outros candidatos. Para tal, basta substituir "Boulos" pelo nome do seu candidato de escolha. Lembre-se que as possibilidades são Milton Leite, Suplicy e Holiday.

```{r calcula votos, message = FALSE}
# Calcula votos por local de votacao
candsp2020_porlv <- candsp2020 |>
  # Filtra somente pelo Boulos
  filter(nm_votavel == "Boulos") |> 
  # Soma os votos do candidato e total da urna por local de votacao
  group_by(nr_zona, nr_local_votacao, nm_votavel) |>
  summarise(votos_cand = sum(qt_votos),
            votos_validos = sum(voto_val_total_secao)) |>
  ungroup() |> 
  # Calcula o percencual de votos por local
  mutate(votos_cand_porc = round(votos_cand/votos_validos*100,1)) 
```

No exercício do mapa do Brasil, utilizamos o comando *left_join* para integrar a base de dados com os ganhadores em cada estado com a base que possuia os polígonos de cada estado (a coluna *geom*). Agora faremos algo muito parecido. Integraremos a base que acabamos de criar (*candsp2020_porlv*) a base que possui os locais de votação (*lvsp2020*). Para tal, também renomeamos o *nr_local_votacao* para *nr_locvot* a fim de assegurar que esta coluna tem o mesmo nome em ambas as bases. Por fim, transformamos as informações em objeto espacial com a função *st_as_sf*.

```{r integra base e LV, message = FALSE}
# Une com a base de LV geolocalizado 
candsp2020_porlv <- candsp2020_porlv |>   
  # Renomeia a variavel nr_local_votacao para facilitar o join
  rename(nr_locvot = nr_local_votacao) |>
  # Traz a informacao da base de LV geolocalizado
  left_join(lvsp2020, by = c("nr_zona", "nr_locvot")) |>
  # Transforma em objeto espacial
  st_as_sf(sf_column_name = "geometry")
```

```{r candidatos-local, message = FALSE}
# Pré-visualização dos votos dos candidatos por local de votação
candsp2020_porlv |> 
  filter(nm_votavel == "Boulos") |> 
  ggplot() +
  geom_sf(data=mapa)+
  geom_sf(aes(size=votos_cand_porc, color=votos_cand_porc))+
  theme_void()
```


*** Obter o bairro do local de votacao

```{r spacial joint, message = FALSE}
# Faz o spatial join
lvsp2020_distrito <- st_join(lvsp2020, mapa)
```

## Problemas acontecem!

```{r problemas, message = FALSE}
nrow(lvsp2020)
nrow(lvsp2020_distrito) # Ele tem uma linha a mais
```

```{r identificando o problema, message = FALSE}
# Isso ocorreu porque um LV está bem na divisa entre dois distritos
ggplot() +
  geom_sf(data=mapa %>% filter(name_district %in% c("Vila Mariana", "Bela Vista")))+
  geom_sf(data = lvsp2020 |> slice(269), size=2)+
  theme_void()
```

```{r solucao, message = FALSE}
# Possivel solução: selecionar aleatoriamente o bairro ao qual ele esta atribuido
lvsp2020_distrito <- lvsp2020_distrito |> 
  group_by(nr_locvot, nr_zona) |> 
  slice_sample(n = 1) |> 
  ungroup() |> 
  # Seleciona so as variaveis que vamos usar para o mapa
  select(nr_zona, nr_locvot, name_district) |> 
  # Retira a geometria, para ela ser tratada como uma tabela
  st_drop_geometry()
nrow(lvsp2020_distrito) # 2.063 linhas, pronto!
```

**** solução: escolher o primeiro bairro que aparece 
* ponto_shape <- st_intersects(lvsp2020, mapa, sparse = T)
* ponto_shape <- unlist(map(ponto_shape, ~.[1])) # faz com que quando exista dois pontos o primeiro seja escolhido
* ponto_shape <- mapa$name_district[ponto_shape]
* ponto_shape[269]
* 
* lvsp2020$bairro <- ponto_shape



```{r agrega votos por distrito, message = FALSE}
# agregação dos votos nos locais de votação por distrito
# mensuração dos votos percentuais por local de votação

candsp2020_pordist <- candsp2020_porlv |>
  # Retira a informacao da geometria do ponto
  st_drop_geometry() |>
  # Traz a informacao do distrito referente ao ponto, que obtivemos acima
  left_join(lvsp2020_distrito, by = c("nr_zona", "nr_locvot"))
```

```{r calcula porcentagem dos votos, message = FALSE}
# Soma os votos do candidato por distrito e calcula o %
candsp2020_pordist <- candsp2020_pordist |> 
  group_by(name_district, nm_votavel) |>
  summarise(votos_cand = sum(votos_cand),
            votos_validos = sum(votos_validos)) |> 
  ungroup() |> 
  mutate(votos_cand_porc = round(votos_cand/votos_validos*100,1)) 
``` 

```{r objeto espacial boulos, message = FALSE}
# Cria um objeto espacial em que passamos para o mapa a votacao
# de Boulos em cada um dos distritos de SP
boulos_final <- left_join(mapa, candsp2020_pordist, by = c("name_district"))
```

```{r mapa-boulos, warning = FALSE}
# pré-visualização dos votos dos candidatos por distrito
boulos_final |> 
  ggplot() +
  geom_sf(aes(fill=votos_cand_porc))+
  theme_void()
```
